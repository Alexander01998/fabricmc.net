/**
* Fabric Command Line tools
* This file contains a bundled TypeScript file with the code and dependencies for the Fabric command line tools.
* It is expected to be ran using https://deno.com/runtime. The source code for this tool can be found at: https://github.com/FabricMC/fabricmc.net
*/
const META = [
    "https://meta.fabricmc.net",
    "https://meta2.fabricmc.net"
];
const MAVEN = [
    "https://maven.fabricmc.net",
    "https://maven2.fabricmc.net"
];
async function getGameVersions() {
    return getJson(META, "/v2/versions/game");
}
async function getLoaderVersions() {
    return getJson(META, "/v2/versions/loader");
}
async function getMinecraftYarnVersions(minecraftVersion) {
    return getJson(META, "/v2/versions/yarn/" + minecraftVersion);
}
function getApiVersions() {
    return getMavenVersions("/net/fabricmc/fabric-api/fabric-api/maven-metadata.xml");
}
function getKotlinAdapterVersions() {
    return getMavenVersions("/net/fabricmc/fabric-language-kotlin/maven-metadata.xml");
}
async function getApiVersionForMinecraft(minecraftVersion) {
    const apiVersions = await getApiVersions();
    return apiVersions.filter((v)=>isApiVersionvalidForMcVersion(v, minecraftVersion)).pop();
}
function isApiVersionvalidForMcVersion(apiVersion, mcVersion) {
    if (!mcVersion) {
        return false;
    }
    let branch = mcVersion;
    let versionBranches = [
        "1.14",
        "1.15",
        "1.16",
        "1.17",
        "1.18",
        "1.19",
        "1.20",
        "20w14infinite",
        "1.18_experimental"
    ];
    versionBranches.forEach((v)=>{
        if (mcVersion.startsWith(v)) {
            branch = v;
        }
    });
    if (mcVersion.startsWith("22w13oneblockatatime")) {
        branch = "22w13oneblockatatime";
    } else if (mcVersion.startsWith("23w")) {
        branch = "1.20.3";
    } else if (mcVersion.startsWith("22w")) {
        branch = "1.19.3";
    } else if (mcVersion.startsWith("1.18.2")) {
        branch = "1.18.2";
    } else if (mcVersion.startsWith("1.19.1")) {
        branch = "1.19.1";
    } else if (mcVersion.startsWith("1.19.2")) {
        branch = "1.19.2";
    } else if (mcVersion.startsWith("1.19.3")) {
        branch = "1.19.3";
    } else if (mcVersion.startsWith("1.19.4")) {
        branch = "1.19.4";
    } else if (mcVersion.startsWith("1.20.1")) {
        branch = "1.20.1";
    } else if (mcVersion.startsWith("1.20.2")) {
        branch = "1.20.2";
    } else if (mcVersion.startsWith("1.20.3")) {
        branch = "1.20.3";
    } else if (mcVersion.startsWith("1.20.4")) {
        branch = "1.20.4";
    } else if (mcVersion.startsWith("21w")) {
        branch = "1.18";
    } else if (mcVersion.startsWith("20w")) {
        branch = "1.17";
    } else if (mcVersion.startsWith("19w") || mcVersion.startsWith("18w")) {
        branch = "1.14";
    }
    return apiVersion.endsWith("-" + branch) || apiVersion.endsWith("+" + branch);
}
let xmlVersionParser = (xml)=>{
    let parser = new DOMParser();
    let xmlDoc = parser.parseFromString(xml, "text/xml");
    return Array.from(xmlDoc.getElementsByTagName("version")).map((v)=>v.childNodes[0].nodeValue);
};
function setXmlVersionParser(parser) {
    xmlVersionParser = parser;
}
async function getMavenVersions(path) {
    let metadata = await getText(MAVEN, path);
    return xmlVersionParser(metadata);
}
async function getJson(hostnames, path) {
    const response = await fetchFallback(hostnames, path);
    return await response.json();
}
async function getText(hostnames, path) {
    const response = await fetchFallback(hostnames, path);
    return await response.text();
}
async function fetchFallback(hostnames, path) {
    for (var hostname of hostnames){
        try {
            const response = await fetch(hostname + path);
            if (response.ok) {
                return response;
            }
            console.error(await response.text());
        } catch (e) {
            console.error(e);
        }
    }
    throw new Error(`Failed to fetch: ${hostnames[0] + path}`);
}
function decode64(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for(var i = 0; i < len; i++){
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}
const gradlew = `#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «\${var}», «\${var:-default}», «\${var+SET}»,
#           «\${var#prefix}», «\${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=\${app_path%"\${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=\${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=\${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "\${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=\${arg#/} t=/\${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a \`for\` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in \`arg\`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect \${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '\${Hostname}' itself on the command line.

set -- \\
        "-Dorg.gradle.appname=$APP_BASE_NAME" \\
        -classpath "$CLASSPATH" \\
        org.gradle.wrapper.GradleWrapperMain \\
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "\${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\\\&~g; ' |
        tr '\\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
`;
const gradlewBat = `@rem\r
@rem Copyright 2015 the original author or authors.\r
@rem\r
@rem Licensed under the Apache License, Version 2.0 (the "License");\r
@rem you may not use this file except in compliance with the License.\r
@rem You may obtain a copy of the License at\r
@rem\r
@rem      https://www.apache.org/licenses/LICENSE-2.0\r
@rem\r
@rem Unless required by applicable law or agreed to in writing, software\r
@rem distributed under the License is distributed on an "AS IS" BASIS,\r
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r
@rem See the License for the specific language governing permissions and\r
@rem limitations under the License.\r
@rem\r
\r
@if "%DEBUG%"=="" @echo off\r
@rem ##########################################################################\r
@rem\r
@rem  Gradle startup script for Windows\r
@rem\r
@rem ##########################################################################\r
\r
@rem Set local scope for the variables with windows NT shell\r
if "%OS%"=="Windows_NT" setlocal\r
\r
set DIRNAME=%~dp0\r
if "%DIRNAME%"=="" set DIRNAME=.\r
@rem This is normally unused\r
set APP_BASE_NAME=%~n0\r
set APP_HOME=%DIRNAME%\r
\r
@rem Resolve any "." and ".." in APP_HOME to make it shorter.\r
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi\r
\r
@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.\r
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"\r
\r
@rem Find java.exe\r
if defined JAVA_HOME goto findJavaFromJavaHome\r
\r
set JAVA_EXE=java.exe\r
%JAVA_EXE% -version >NUL 2>&1\r
if %ERRORLEVEL% equ 0 goto execute\r
\r
echo.\r
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.\r
echo.\r
echo Please set the JAVA_HOME variable in your environment to match the\r
echo location of your Java installation.\r
\r
goto fail\r
\r
:findJavaFromJavaHome\r
set JAVA_HOME=%JAVA_HOME:"=%\r
set JAVA_EXE=%JAVA_HOME%/bin/java.exe\r
\r
if exist "%JAVA_EXE%" goto execute\r
\r
echo.\r
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%\r
echo.\r
echo Please set the JAVA_HOME variable in your environment to match the\r
echo location of your Java installation.\r
\r
goto fail\r
\r
:execute\r
@rem Setup the command line\r
\r
set CLASSPATH=%APP_HOME%\\gradle\\wrapper\\gradle-wrapper.jar\r
\r
\r
@rem Execute Gradle\r
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*\r
\r
:end\r
@rem End local scope for the variables with windows NT shell\r
if %ERRORLEVEL% equ 0 goto mainEnd\r
\r
:fail\r
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of\r
rem the _cmd.exe /c_ return code!\r
set EXIT_CODE=%ERRORLEVEL%\r
if %EXIT_CODE% equ 0 set EXIT_CODE=1\r
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%\r
exit /b %EXIT_CODE%\r
\r
:mainEnd\r
if "%OS%"=="Windows_NT" endlocal\r
\r
:omega\r
`;
const gradleWrapperProperties = "distributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-8.5-bin.zip\nnetworkTimeout=10000\nvalidateDistributionUrl=true\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n";
const gradleWrapperJar = "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L2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIkQWZ0ZXJPcHRpb25zLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAB9e8LctAwAAXQcAADwACQAAAAAAAAAAAAAA1hUAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJEJlZm9yZUZpcnN0U3ViQ29tbWFuZC5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQBYgpgP2AYAAGIOAAA9AAkAAAAAAAAAAAAAAHYZAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRLbm93bk9wdGlvblBhcnNlclN0YXRlLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhANImcdNMAgAAlwQAADwACQAAAAAAAAAAAAAAwiAAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJE1pc3NpbmdPcHRpb25BcmdTdGF0ZS5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQAvy2DF1wIAAEoFAAA9AAkAAAAAAAAAAAAAAIEjAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRPcHRpb25Bd2FyZVBhcnNlclN0YXRlLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAAb4QlWkAQAAfQIAADgACQAAAAAAAAAAAAAAzCYAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJE9wdGlvblBhcnNlclN0YXRlLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAIETaMkNAgAAQwMAADMACQAAAAAAAAAAAAAA3ygAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJE9wdGlvblN0cmluZy5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQDZoNqjpwEAAM4CAAAyAAkAAAAAAAAAAAAAAFYrAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRQYXJzZXJTdGF0ZS5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQAAjGddcwIAAMcEAAA/AAkAAAAAAAAAAAAAAGYtAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRVbmtub3duT3B0aW9uUGFyc2VyU3RhdGUuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAxbgfPrEEAABjCAAAJgAJAAAAAAAAAAAAAABPMAAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEA829HuTsEAADhBwAAJgAJAAAAAAAAAAAAAABdNQAAb3JnL2dyYWRsZS9jbGkvUGFyc2VkQ29tbWFuZExpbmUuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAyioNQVMBAACsAQAALAAJAAAAAAAAAAAAAAD1OQAAb3JnL2dyYWRsZS9jbGkvUGFyc2VkQ29tbWFuZExpbmVPcHRpb24uY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEA2JZpfgEDAACcBAAAMwAJAAAAAAAAAAAAAACrOwAAb3JnL2dyYWRsZS9pbnRlcm5hbC9maWxlL1BhdGhUcmF2ZXJzYWxDaGVja2VyLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAFAafz3CAQAAowIAAD4ACQAAAAAAAAAAAAAAFj8AAG9yZy9ncmFkbGUvdXRpbC9pbnRlcm5hbC9XcmFwcGVyRGlzdHJpYnV0aW9uVXJsQ29udmVydGVyLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAM8OjbmPAQAAHgIAAC8ACQAAAAAAAAAAAAAATUEAAG9yZy9ncmFkbGUvd3JhcHBlci9Cb290c3RyYXBNYWluU3RhcnRlciQxLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhACZHXY8pAwAA5AQAAEEACQAAAAAAAAAAAAAAQkMAAG9yZy9ncmFkbGUvd3JhcHBlci9Eb3dubG9hZCREZWZhdWx0RG93bmxvYWRQcm9ncmVzc0xpc3RlbmVyLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAFSneKkfAwAAowUAADQACQAAAAAAAAAAAAAA40YAAG9yZy9ncmFkbGUvd3JhcHBlci9Eb3dubG9hZCRQcm94eUF1dGhlbnRpY2F0b3IuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAjLvDsGYJAAA1EgAAIQAJAAAAAAAAAAAAAABtSgAAb3JnL2dyYWRsZS93cmFwcGVyL0Rvd25sb2FkLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAPGMLh9/AQAA9QEAADMACQAAAAAAAAAAAAAAK1QAAG9yZy9ncmFkbGUvd3JhcHBlci9FeGNsdXNpdmVGaWxlQWNjZXNzTWFuYWdlci5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQALfn7P2QEAALICAAAtAAkAAAAAAAAAAAAAABRWAABvcmcvZ3JhZGxlL3dyYXBwZXIvR3JhZGxlVXNlckhvbWVMb29rdXAuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAq+86IP8UAACNKQAAKgAJAAAAAAAAAAAAAABRWAAAb3JnL2dyYWRsZS93cmFwcGVyL0dyYWRsZVdyYXBwZXJNYWluLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhADThlEzDCwAAuhUAACIACQAAAAAAAAAAAAAAsW0AAG9yZy9ncmFkbGUvd3JhcHBlci9JbnN0YWxsJDEuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAkyTtAGoBAADnAQAALQAJAAAAAAAAAAAAAADNeQAAb3JnL2dyYWRsZS93cmFwcGVyL0luc3RhbGwkSW5zdGFsbENoZWNrLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAEtDILafDgAAvhsAACAACQAAAAAAAAAAAAAAm3sAAG9yZy9ncmFkbGUvd3JhcHBlci9JbnN0YWxsLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAOqbsNk8AgAAHgQAAB8ACQAAAAAAAAAAAAAAkYoAAG9yZy9ncmFkbGUvd3JhcHBlci9Mb2dnZXIuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAp18O2iQBAABqAQAAJgAJAAAAAAAAAAAAAAAjjQAAb3JnL2dyYWRsZS93cmFwcGVyL1BhdGhBc3NlbWJsZXIuY2xhc3NVVAUAAQAAAABQSwECFAAUAAgICAAAACEAeqxO8JwDAABOBgAAMAAJAAAAAAAAAAAAAACkjgAAb3JnL2dyYWRsZS93cmFwcGVyL1N5c3RlbVByb3BlcnRpZXNIYW5kbGVyLmNsYXNzVVQFAAEAAAAAUEsBAhQAFAAICAgAAAAhAGni1S3vAgAAUAYAAC0ACQAAAAAAAAAAAAAAp5IAAG9yZy9ncmFkbGUvd3JhcHBlci9XcmFwcGVyQ29uZmlndXJhdGlvbi5jbGFzc1VUBQABAAAAAFBLAQIUABQACAgIAAAAIQCuENrgUwYAAMUMAAAoAAkAAAAAAAAAAAAAAPqVAABvcmcvZ3JhZGxlL3dyYXBwZXIvV3JhcHBlckV4ZWN1dG9yLmNsYXNzVVQFAAEAAAAAUEsFBgAAAAAhACEABA0AAKycAAAAAA==";
const gitignore = "# gradle\n\n.gradle/\nbuild/\nout/\nclasses/\n\n# eclipse\n\n*.launch\n\n# idea\n\n.idea/\n*.iml\n*.ipr\n*.iws\n\n# vscode\n\n.settings/\n.vscode/\nbin/\n.classpath\n.project\n\n# macos\n\n*.DS_Store\n\n# fabric\n\nrun/\n\n# java\n\nhs_err_*.log\nreplay_*.log\n*.hprof\n*.jfr\n";
const workflow = "# Automatically build the project and run any configured tests for every push\n# and submitted pull request. This can help catch issues that only occur on\n# certain platforms or Java versions, and provides a first line of defence\n# against bad commits.\n\nname: build\non: [pull_request, push]\n\njobs:\n  build:\n    strategy:\n      matrix:\n        # Use these Java versions\n        java: [\n          17,    # Current Java LTS & minimum supported by Minecraft\n          21,    # Current Java LTS\n        ]\n        # and run on both Linux and Windows\n        os: [ubuntu-22.04, windows-2022]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v4\n      - name: validate gradle wrapper\n        uses: gradle/wrapper-validation-action@v1\n      - name: setup jdk ${{ matrix.java }}\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ matrix.java }}\n          distribution: 'microsoft'\n      - name: make gradle wrapper executable\n        if: ${{ runner.os != 'Windows' }}\n        run: chmod +x ./gradlew\n      - name: build\n        run: ./gradlew build\n      - name: capture build artifacts\n        if: ${{ runner.os == 'Linux' && matrix.java == '21' }} # Only upload artifacts built from latest java on one OS\n        uses: actions/upload-artifact@v3\n        with:\n          name: Artifacts\n          path: build/libs/";
async function addGradleWrapper({ writer  }) {
    await writer.write("gradlew", gradlew, {
        executable: true
    });
    await writer.write("gradlew.bat", gradlewBat);
    await writer.write("gradle/wrapper/gradle-wrapper.properties", gradleWrapperProperties);
    await writer.write("gradle/wrapper/gradle-wrapper.jar", decode64(gradleWrapperJar));
    await writer.write(".gitignore", gitignore);
    await writer.write(".github/workflows/build.yml", workflow);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var browser_umd = {
    exports: {}
};
(function(module, exports) {
    !function(t, e) {
        e(exports);
    }(commonjsGlobal, function(t) {
        function e() {
            return e = Object.assign ? Object.assign.bind() : function(t2) {
                for(var e2 = 1; e2 < arguments.length; e2++){
                    var n2 = arguments[e2];
                    for(var r2 in n2)Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
                }
                return t2;
            }, e.apply(this, arguments);
        }
        function n(t2, e2) {
            t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, i(t2, e2);
        }
        function r(t2) {
            return r = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
                return t3.__proto__ || Object.getPrototypeOf(t3);
            }, r(t2);
        }
        function i(t2, e2) {
            return i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
                return t3.__proto__ = e3, t3;
            }, i(t2, e2);
        }
        function a(t2, e2, n2) {
            return a = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return false;
                if (Reflect.construct.sham) return false;
                if ("function" == typeof Proxy) return true;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), true;
                } catch (t3) {
                    return false;
                }
            }() ? Reflect.construct.bind() : function(t3, e3, n3) {
                var r2 = [
                    null
                ];
                r2.push.apply(r2, e3);
                var a2 = new (Function.bind.apply(t3, r2))();
                return n3 && i(a2, n3.prototype), a2;
            }, a.apply(null, arguments);
        }
        function s(t2) {
            var e2 = "function" == typeof Map ? new Map() : void 0;
            return s = function(t3) {
                if (null === t3 || -1 === Function.toString.call(t3).indexOf("[native code]")) return t3;
                if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e2) {
                    if (e2.has(t3)) return e2.get(t3);
                    e2.set(t3, n2);
                }
                function n2() {
                    return a(t3, arguments, r(this).constructor);
                }
                return n2.prototype = Object.create(t3.prototype, {
                    constructor: {
                        value: n2,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                }), i(n2, t3);
            }, s(t2);
        }
        var o = function() {
            function t2(t3) {
                this.cache = void 0, this.cache = t3;
            }
            var n2 = t2.prototype;
            return n2.define = function(t3, e2) {
                this.cache[t3] = e2;
            }, n2.get = function(t3) {
                return this.cache[t3];
            }, n2.remove = function(t3) {
                delete this.cache[t3];
            }, n2.reset = function() {
                this.cache = {};
            }, n2.load = function(t3) {
                this.cache = e({}, this.cache, t3);
            }, t2;
        }(), c = function(t2) {
            function e2(e3) {
                var n2;
                return (n2 = t2.call(this, e3) || this).name = "Eta Error", n2;
            }
            return n(e2, t2), e2;
        }(s(Error));
        function l(t2, e2, n2) {
            var r2 = e2.slice(0, n2).split(/\n/), i2 = r2.length, a2 = r2[i2 - 1].length + 1;
            throw t2 += " at line " + i2 + " col " + a2 + ":\n\n  " + e2.split(/\n/)[i2 - 1] + "\n  " + Array(a2).join(" ") + "^", new c(t2);
        }
        function u(t2, e2, n2, r2) {
            var i2 = e2.split("\n"), a2 = Math.max(n2 - 3, 0), s2 = Math.min(i2.length, n2 + 3), o2 = r2, l2 = i2.slice(a2, s2).map(function(t3, e3) {
                var r3 = e3 + a2 + 1;
                return (r3 == n2 ? " >> " : "    ") + r3 + "| " + t3;
            }).join("\n"), u2 = new c((o2 ? o2 + ":" + n2 + "\n" : "line " + n2 + "\n") + l2 + "\n\n" + t2.message);
            throw u2.name = t2.name, u2;
        }
        var f = (function() {
            return Promise.resolve();
        }).constructor;
        function p(t2, e2) {
            var n2 = this.config, r2 = e2 && e2.async ? f : Function;
            try {
                return new r2(n2.varName, "options", this.compileToString.call(this, t2, e2));
            } catch (n3) {
                throw n3 instanceof SyntaxError ? new c("Bad template syntax\n\n" + n3.message + "\n" + Array(n3.message.length + 1).join("=") + "\n" + this.compileToString.call(this, t2, e2) + "\n") : n3;
            }
        }
        function h(t2, e2) {
            var n2 = this.config, r2 = e2 && e2.async, i2 = this.parse.call(this, t2), a2 = n2.functionHeader + '\nlet include = (template, data) => this.render(template, data, options);\nlet includeAsync = (template, data) => this.renderAsync(template, data, options);\n\nlet __eta = {res: "", e: this.config.escapeFunction, f: this.config.filterFunction' + (n2.debug ? ', line: 1, templateStr: "' + t2.replace(/\\|'/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n") + '"' : "") + "};\n\nfunction layout(path, data) {\n  __eta.layout = path;\n  __eta.layoutData = data;\n}" + (n2.debug ? "try {" : "") + (n2.useWith ? "with(" + n2.varName + "||{}){" : "") + "\n\n" + d.call(this, i2) + "\nif (__eta.layout) {\n  __eta.res = " + (r2 ? "await includeAsync" : "include") + " (__eta.layout, {..." + n2.varName + ", body: __eta.res, ...__eta.layoutData});\n}\n" + (n2.useWith ? "}" : "") + (n2.debug ? "} catch (e) { this.RuntimeErr(e, __eta.templateStr, __eta.line, options.filepath) }" : "") + "\nreturn __eta.res;\n";
            if (n2.plugins) for(var s2 = 0; s2 < n2.plugins.length; s2++){
                var o2 = n2.plugins[s2];
                o2.processFnString && (a2 = o2.processFnString(a2, n2));
            }
            return a2;
        }
        function d(t2) {
            for(var e2 = this.config, n2 = 0, r2 = t2.length, i2 = ""; n2 < r2; n2++){
                var a2 = t2[n2];
                if ("string" == typeof a2) i2 += "__eta.res+='" + a2 + "'\n";
                else {
                    var s2 = a2.t, o2 = a2.val || "";
                    e2.debug && (i2 += "__eta.line=" + a2.lineNo + "\n"), "r" === s2 ? (e2.autoFilter && (o2 = "__eta.f(" + o2 + ")"), i2 += "__eta.res+=" + o2 + "\n") : "i" === s2 ? (e2.autoFilter && (o2 = "__eta.f(" + o2 + ")"), e2.autoEscape && (o2 = "__eta.e(" + o2 + ")"), i2 += "__eta.res+=" + o2 + "\n") : "e" === s2 && (i2 += o2 + "\n");
                }
            }
            return i2;
        }
        var g = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        function y(t2) {
            return g[t2];
        }
        var v = {
            autoEscape: true,
            autoFilter: false,
            autoTrim: [
                false,
                "nl"
            ],
            cache: false,
            cacheFilepaths: true,
            debug: false,
            escapeFunction: function(t2) {
                var e2 = String(t2);
                return /[&<>"']/.test(e2) ? e2.replace(/[&<>"']/g, y) : e2;
            },
            filterFunction: function(t2) {
                return String(t2);
            },
            functionHeader: "",
            parse: {
                exec: "",
                interpolate: "=",
                raw: "~"
            },
            plugins: [],
            rmWhitespace: false,
            tags: [
                "<%",
                "%>"
            ],
            useWith: false,
            varName: "it"
        }, m = /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\${)[^\\`])*`/g, x = /'(?:\\[\s\w"'\\`]|[^\n\r'\\])*?'/g, _ = /"(?:\\[\s\w"'\\`]|[^\n\r"\\])*?"/g;
        function b(t2) {
            return t2.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
        }
        function w(t2, e2) {
            return t2.slice(0, e2).split("\n").length;
        }
        function S(t2) {
            var e2 = this.config, n2 = [], r2 = false, i2 = 0, a2 = e2.parse;
            if (e2.plugins) for(var s2 = 0; s2 < e2.plugins.length; s2++){
                var o2 = e2.plugins[s2];
                o2.processTemplate && (t2 = o2.processTemplate(t2, e2));
            }
            function c2(t3, i3) {
                t3 && (t3 = function(t4, e3, n3, r3) {
                    var i4, a3;
                    return Array.isArray(e3.autoTrim) ? (i4 = e3.autoTrim[1], a3 = e3.autoTrim[0]) : i4 = a3 = e3.autoTrim, (n3 || false === n3) && (i4 = n3), (r3 || false === r3) && (a3 = r3), a3 || i4 ? "slurp" === i4 && "slurp" === a3 ? t4.trim() : ("_" === i4 || "slurp" === i4 ? t4 = t4.trimStart() : "-" !== i4 && "nl" !== i4 || (t4 = t4.replace(/^(?:\r\n|\n|\r)/, "")), "_" === a3 || "slurp" === a3 ? t4 = t4.trimEnd() : "-" !== a3 && "nl" !== a3 || (t4 = t4.replace(/(?:\r\n|\n|\r)$/, "")), t4) : t4;
                }(t3, e2, r2, i3), t3 && (t3 = t3.replace(/\\|'/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n"), n2.push(t3)));
            }
            e2.rmWhitespace && (t2 = t2.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "")), m.lastIndex = 0, x.lastIndex = 0, _.lastIndex = 0;
            for(var u2, f2 = [
                a2.exec,
                a2.interpolate,
                a2.raw
            ].reduce(function(t3, e3) {
                return t3 && e3 ? t3 + "|" + b(e3) : e3 ? b(e3) : t3;
            }, ""), p2 = new RegExp(b(e2.tags[0]) + "(-|_)?\\s*(" + f2 + ")?\\s*", "g"), h2 = new RegExp("'|\"|`|\\/\\*|(\\s*(-|_)?" + b(e2.tags[1]) + ")", "g"); u2 = p2.exec(t2);){
                var d2 = t2.slice(i2, u2.index);
                i2 = u2[0].length + u2.index;
                var g2 = u2[2] || "";
                c2(d2, u2[1]), h2.lastIndex = i2;
                for(var y2 = void 0, v2 = false; y2 = h2.exec(t2);){
                    if (y2[1]) {
                        var S2 = t2.slice(i2, y2.index);
                        p2.lastIndex = i2 = h2.lastIndex, r2 = y2[2], v2 = {
                            t: g2 === a2.exec ? "e" : g2 === a2.raw ? "r" : g2 === a2.interpolate ? "i" : "",
                            val: S2
                        };
                        break;
                    }
                    var F2 = y2[0];
                    if ("/*" === F2) {
                        var O2 = t2.indexOf("*/", h2.lastIndex);
                        -1 === O2 && l("unclosed comment", t2, y2.index), h2.lastIndex = O2;
                    } else "'" === F2 ? (x.lastIndex = y2.index, x.exec(t2) ? h2.lastIndex = x.lastIndex : l("unclosed string", t2, y2.index)) : '"' === F2 ? (_.lastIndex = y2.index, _.exec(t2) ? h2.lastIndex = _.lastIndex : l("unclosed string", t2, y2.index)) : "`" === F2 && (m.lastIndex = y2.index, m.exec(t2) ? h2.lastIndex = m.lastIndex : l("unclosed string", t2, y2.index));
                }
                v2 ? (e2.debug && (v2.lineNo = w(t2, u2.index)), n2.push(v2)) : l("unclosed tag", t2, u2.index);
            }
            if (c2(t2.slice(i2, t2.length), false), e2.plugins) for(var I2 = 0; I2 < e2.plugins.length; I2++){
                var A2 = e2.plugins[I2];
                A2.processAST && (n2 = A2.processAST(n2, e2));
            }
            return n2;
        }
        function F(t2, e2) {
            var n2 = e2 && e2.async ? this.templatesAsync : this.templatesSync;
            if (this.resolvePath && this.readFile && !t2.startsWith("@")) {
                var r2 = e2.filepath, i2 = n2.get(r2);
                if (this.config.cache && i2) return i2;
                var a2 = this.readFile(r2), s2 = this.compile(a2, e2);
                return this.config.cache && n2.define(r2, s2), s2;
            }
            var o2 = n2.get(t2);
            if (o2) return o2;
            throw new c("Failed to get template '" + t2 + "'");
        }
        function O(t2, n2, r2) {
            var i2, a2 = e({}, r2, {
                async: false
            });
            return "string" == typeof t2 ? (this.resolvePath && this.readFile && !t2.startsWith("@") && (a2.filepath = this.resolvePath(t2, a2)), i2 = F.call(this, t2, a2)) : i2 = t2, i2.call(this, n2, a2);
        }
        function I(t2, n2, r2) {
            var i2, a2 = e({}, r2, {
                async: true
            });
            "string" == typeof t2 ? (this.resolvePath && this.readFile && !t2.startsWith("@") && (a2.filepath = this.resolvePath(t2, a2)), i2 = F.call(this, t2, a2)) : i2 = t2;
            var s2 = i2.call(this, n2, a2);
            return Promise.resolve(s2);
        }
        function A(t2, e2) {
            var n2 = this.compile(t2, {
                async: false
            });
            return O.call(this, n2, e2);
        }
        function T(t2, e2) {
            var n2 = this.compile(t2, {
                async: true
            });
            return I.call(this, n2, e2);
        }
        var P = function() {
            function t2(t3) {
                this.config = void 0, this.RuntimeErr = u, this.compile = p, this.compileToString = h, this.parse = S, this.render = O, this.renderAsync = I, this.renderString = A, this.renderStringAsync = T, this.filepathCache = {}, this.templatesSync = new o({}), this.templatesAsync = new o({}), this.resolvePath = null, this.readFile = null, this.config = t3 ? e({}, v, t3) : e({}, v);
            }
            var n2 = t2.prototype;
            return n2.configure = function(t3) {
                this.config = e({}, this.config, t3);
            }, n2.withConfig = function(t3) {
                return e({}, this, {
                    config: e({}, this.config, t3)
                });
            }, n2.loadTemplate = function(t3, e2, n3) {
                if ("string" == typeof e2) (n3 && n3.async ? this.templatesAsync : this.templatesSync).define(t3, this.compile(e2, n3));
                else {
                    var r2 = this.templatesSync;
                    ("AsyncFunction" === e2.constructor.name || n3 && n3.async) && (r2 = this.templatesAsync), r2.define(t3, e2);
                }
            }, t2;
        }(), j = function(t2) {
            function e2() {
                return t2.apply(this, arguments) || this;
            }
            return n(e2, t2), e2;
        }(P);
        t.Eta = j;
    });
})(browser_umd, browser_umd.exports);
var browser_umdExports = browser_umd.exports;
const eta = new browser_umdExports.Eta({
    autoTrim: false
});
function renderTemplate(template, options) {
    return eta.renderString(template, options);
}
const gradlePropertiesTemplate = "# Done to increase the memory available to gradle.\norg.gradle.jvmargs=-Xmx1G\norg.gradle.parallel=true\n\n# Fabric Properties\n# check these on https://fabricmc.net/develop\nminecraft_version=<%= it.minecraftVersion %>\nyarn_mappings=<%= it.yarnVersion %>\nloader_version=<%= it.loaderVersion %>\n<% if (it.kotlin) { %>fabric_kotlin_version=<%= it.kotlin.fabricKotlinAdapterVersion %>\n<% } %>\n# Mod Properties\nmod_version=1.0.0\nmaven_group=<%= it.packageName %>\narchives_base_name=<%= it.modid %>\n\n# Dependencies\nfabric_version=<%= it.fabricVersion %>";
const buildGradleTemplate = 'plugins {\n	id \'fabric-loom\' version \'1.4-SNAPSHOT\'\n	id \'maven-publish\'\n	<%_ if (it.kotlin) { %>\n  id "org.jetbrains.kotlin.jvm" version "<%= it.kotlin.kotlinVersion %>"\n  <%_ } %>\n}\n\nversion = project.mod_version\ngroup = project.maven_group\n\nbase {\n	archivesName = project.archives_base_name\n}\n\nrepositories {\n	// Add repositories to retrieve artifacts from in here.\n	// You should only use this when depending on other mods because\n	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.\n	// See https://docs.gradle.org/current/userguide/declaring_repositories.html\n	// for more information about repositories.\n}\n<% if (it.splitSources) { %>\nloom {\n<% if (it.splitSources) { %>    splitEnvironmentSourceSets()\n\n	mods {\n		"<%= it.modid %>" {\n			sourceSet sourceSets.main\n			sourceSet sourceSets.client\n		}\n	}\n<% } %>\n}\n<% } %><% if (it.dataGeneration) { %>\nfabricApi {\n	configureDataGeneration()\n}\n<% } %>\ndependencies {\n	// To change the versions see the gradle.properties file\n	minecraft "com.mojang:minecraft:${project.minecraft_version}"\n	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"\n	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"\n\n	// Fabric API. This is technically optional, but you probably want it anyway.\n	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"\n	<% if (it.kotlin) { %>modImplementation "net.fabricmc:fabric-language-kotlin:${project.fabric_kotlin_version}"<% } %>\n	// Uncomment the following line to enable the deprecated Fabric API modules. \n	// These are included in the Fabric API production distribution and allow you to update your mod to the latest modules at a later more convenient time.\n\n	// modImplementation "net.fabricmc.fabric-api:fabric-api-deprecated:${project.fabric_version}"\n}\n\nprocessResources {\n	inputs.property "version", project.version\n\n	filesMatching("fabric.mod.json") {\n		expand "version": project.version\n	}\n}\n\ntasks.withType(JavaCompile).configureEach {\n	it.options.release = <%= it.java.release %>\n}\n<% if (it.kotlin) { %>\ntasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {\n	kotlinOptions {\n		jvmTarget = <%= it.java.kotlinRelease %>\n	}\n}\n<% } %>\njava {\n	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task\n	// if it is present.\n	// If you remove this line, sources will not be generated.\n	withSourcesJar()\n\n	sourceCompatibility = JavaVersion.<%= it.java.compatibility %>\n	targetCompatibility = JavaVersion.<%= it.java.compatibility %>\n}\n\njar {\n	from("LICENSE") {\n		rename { "${it}_${project.base.archivesName.get()}"}\n	}\n}\n\n// configure the maven publication\npublishing {\n	publications {\n		mavenJava(MavenPublication) {\n			from components.java\n		}\n	}\n\n	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.\n	repositories {\n		// Add repositories to publish to here.\n		// Notice: This block does NOT have the same function as the block in the top level.\n		// The repositories here will be used for publishing your artifact, not for\n		// retrieving dependencies.\n	}\n}';
const settingsGradle = "pluginManagement {\n	repositories {\n		maven {\n			name = 'Fabric'\n			url = 'https://maven.fabricmc.net/'\n		}\n		mavenCentral()\n		gradlePluginPortal()\n	}\n}";
function minecraftSupportsDataGen(minecraftVersion) {
    return getMinorMinecraftVersion(minecraftVersion) >= 17;
}
function minecraftSupportsSplitSources(minecraftVersion) {
    return getMinorMinecraftVersion(minecraftVersion) >= 19;
}
function getMinorMinecraftVersion(minecraftVersion) {
    return Number(minecraftVersion.split(".")[1]);
}
function sharedModIdChecks(id, isId) {
    let errorList = [];
    const type = isId ? "Modid" : "Mod Name";
    if (id.length == 0) {
        return [
            `${type} is empty!`
        ];
    } else if (id.length == 1) {
        errorList.push(`${type} is only a single character! (It must be at least 2 characters long)!`);
    } else if (id.length > 64) {
        errorList.push(`${type} has more than 64 characters!`);
    }
    if (id.toLocaleLowerCase().startsWith("fabric")) {
        errorList.push("Mod id starts with 'fabric', which is generally reserved for Fabric itself.");
    }
    return errorList.length === 0 ? void 0 : errorList;
}
function computeCustomModIdErrors(id) {
    if (id === void 0) {
        return void 0;
    }
    let errorList = sharedModIdChecks(id, true) ?? [];
    const first = id.charAt(0);
    if (first < "a" || first > "z") {
        errorList.push("Modid starts with an invalid character '" + first + "' (it must belowercase a-z)");
    }
    let invalidChars = null;
    for(let i = 1; i < id.length; i++){
        let c = id.charAt(i);
        if (c == "-" || c == "_" || "0" <= c && c <= "9" || "a" <= c && c <= "z") {
            continue;
        }
        if (invalidChars == null) {
            invalidChars = [];
        }
        invalidChars.push(c);
    }
    if (invalidChars != null) {
        let error = "Modid contains invalid characters: " + invalidChars.map((value)=>"'" + value + "'").join(", ") + "!";
        errorList.push(error + "!");
    }
    if (errorList.length == 0) {
        return void 0;
    }
    return errorList;
}
function formatPackageName(packageName) {
    return packageName.toLocaleLowerCase().replace(/\s+/g, ".").replace(/[^a-za-z0-9_\.]/, "");
}
function nameToModId(name) {
    return name.toLowerCase().replaceAll(/\s+/g, "-").replaceAll(/[^a-za-z0-9-_]/g, "");
}
const JAVA_8 = {
    compatibility: "VERSION_1_8",
    mixin: "JAVA_8",
    release: 8,
    kotlinRelease: "1.8"
};
const JAVA_16 = {
    compatibility: "VERSION_16",
    mixin: "JAVA_16",
    release: 16,
    kotlinRelease: "16"
};
const JAVA_17 = {
    compatibility: "VERSION_17",
    mixin: "JAVA_17",
    release: 17,
    kotlinRelease: "17"
};
function getJavaVersion(minecraftVersion) {
    const minor = getMinorMinecraftVersion(minecraftVersion);
    if (minor < 16) {
        return JAVA_8;
    } else if (minor == 16) {
        return JAVA_16;
    }
    return JAVA_17;
}
const JAVA_PACKAGE_REGEX = /^[a-z][a-z0-9_]*(\.[a-z0-9_]+)+[0-9a-z_]$/;
const RESERVED_PACKAGE_PREFIXES = [
    "net.minecraft.",
    "com.mojang.",
    "net.fabricmc.",
    "java."
];
function computePackageNameErrors(packageName) {
    let errorList = [];
    if (!JAVA_PACKAGE_REGEX.test(packageName.toLowerCase())) {
        errorList.push("Package name is not a valid Java package name!");
    }
    for (let prefix of RESERVED_PACKAGE_PREFIXES){
        if (packageName.toLowerCase().startsWith(prefix)) {
            errorList.push(`Package name starts with '${prefix}', which is reserved!`);
        } else if (packageName.toLowerCase() + "." == prefix) {
            errorList.push(`Package name is '${prefix}', which is reserved!`);
        }
    }
    return errorList;
}
async function addGroovyGradle(writer, config) {
    await writer.write("gradle.properties", renderTemplate(gradlePropertiesTemplate, config));
    await writer.write("build.gradle", renderTemplate(buildGradleTemplate, {
        ...config,
        java: getJavaVersion(config.minecraftVersion)
    }));
    await writer.write("settings.gradle", settingsGradle);
}
const mixinTemplate = 'package <%= it.packageName %>;\n\nimport net.minecraft.server.MinecraftServer;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(MinecraftServer.class)\npublic class <%= it.className %> {\n	@Inject(at = @At("HEAD"), method = "loadWorld")\n	private void init(CallbackInfo info) {\n		// This code is injected into the start of MinecraftServer.loadWorld()V\n	}\n}';
const mixinClientTemplate = 'package <%= it.packageName %>;\n\nimport net.minecraft.client.MinecraftClient;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(MinecraftClient.class)\npublic class <%= it.className %> {\n	@Inject(at = @At("HEAD"), method = "run")\n	private void run(CallbackInfo info) {\n		// This code is injected into the start of MinecraftClient.run()V\n	}\n}';
async function generateMixin(writer, options) {
    const packageName = options.packageName + ".mixin";
    const className = "ExampleMixin";
    const mixinJson = {
        "required": true,
        "package": packageName,
        "compatibilityLevel": getJavaVersion(options.minecraftVersion).mixin,
        "mixins": [
            className
        ],
        "injectors": {
            "defaultRequire": 1
        }
    };
    const mixinJsonName = `${options.modid}.mixins.json`;
    await writer.write(`src/main/resources/${mixinJsonName}`, JSON.stringify(mixinJson, null, "	"));
    await writer.write(`src/main/java/${packageName.replaceAll(".", "/")}/${className}.java`, renderTemplate(mixinTemplate, {
        className,
        packageName
    }));
    return [
        mixinJsonName
    ];
}
async function generateClientMixin(writer, options) {
    const packageName = options.packageName + ".mixin.client";
    const className = "ExampleClientMixin";
    const mixinJson = {
        "required": true,
        "package": packageName,
        "compatibilityLevel": getJavaVersion(options.minecraftVersion).mixin,
        "client": [
            className
        ],
        "injectors": {
            "defaultRequire": 1
        }
    };
    const mixinJsonName = `${options.modid}.client.mixins.json`;
    await writer.write(`src/client/resources/${mixinJsonName}`, JSON.stringify(mixinJson, null, "	"));
    await writer.write(`src/client/java/${packageName.replaceAll(".", "/")}/${className}.java`, renderTemplate(mixinClientTemplate, {
        className,
        packageName
    }));
    return [
        {
            "config": mixinJsonName,
            "environment": "client"
        }
    ];
}
const javaEntrypointTemplate = `package <%= it.package %>;

import net.fabricmc.api.ModInitializer;
<% if (it.slf4j) { %>
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
<% } else { %>
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
<% } %>
public class <%= it.className %> implements ModInitializer {
	// This logger is used to write text to the console and the log file.
	// It is considered best practice to use your mod id as the logger's name.
	// That way, it's clear which mod wrote info, warnings, and errors.
<% if (it.slf4j) { %>    public static final Logger LOGGER = LoggerFactory.getLogger("<%= it.modid %>");
<% } else { %>    public static final Logger LOGGER = LogManager.getLogger("<%= it.modid %>");<% } %>
	@Override
	public void onInitialize() {
		// This code runs as soon as Minecraft is in a mod-load-ready state.
		// However, some things (like resources) may still be uninitialized.
		// Proceed with mild caution.

		LOGGER.info("Hello Fabric world!");
	}
}`;
const kotlinEntrypointTemplate = 'package <%= it.package %>\n\nimport net.fabricmc.api.ModInitializer\n<% if (it.slf4j) { %>import org.slf4j.LoggerFactory\n<% } else { %>import org.apache.logging.log4j.LogManager<% } %>\nobject <%= it.className %> : ModInitializer {\n<% if (it.slf4j) { %>    private val logger = LoggerFactory.getLogger("<%= it.modid %>")\n<% } else { %>    private val logger = LogManager.getLogger("<%= it.modid %>")<% } %>\n	override fun onInitialize() {\n		// This code runs as soon as Minecraft is in a mod-load-ready state.\n		// However, some things (like resources) may still be uninitialized.\n		// Proceed with mild caution.\n		logger.info("Hello Fabric world!")\n	}\n}';
const javaEntrypointClientTemplate = "package <%= it.package %>;\n\nimport net.fabricmc.api.ClientModInitializer;\n\npublic class <%= it.className %> implements ClientModInitializer {\n	@Override\n	public void onInitializeClient() {\n		// This entrypoint is suitable for setting up client-specific logic, such as rendering.\n	}\n}";
const kotlinEntrypointClientTemplate = "package <%= it.package %>\n\nimport net.fabricmc.api.ClientModInitializer\n\nobject <%= it.className %> : ClientModInitializer {\n	override fun onInitializeClient() {\n		// This entrypoint is suitable for setting up client-specific logic, such as rendering.\n	}\n}";
const javaEntrypointDataGeneratorTemplate = "package <%= it.package %>;\n\nimport net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;\n\npublic class <%= it.className %> implements DataGeneratorEntrypoint {\n	@Override\n	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {\n\n	}\n}\n";
const kotlinEntrypointDataGeneratorTemplate = "package <%= it.package %>\n\nimport net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint\nimport net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator\n\nobject <%= it.className %> : DataGeneratorEntrypoint {\n	override fun onInitializeDataGenerator(fabricDataGenerator: FabricDataGenerator) {\n	}\n}";
async function generateEntrypoint(writer, options) {
    const className = formatClassname(options.projectName);
    const classOptions = {
        package: options.packageName,
        className,
        classFullName: options.packageName + "." + className,
        path: options.packageName.replaceAll(".", "/") + "/" + className,
        modid: options.modid,
        slf4j: getMinorMinecraftVersion(options.minecraftVersion) >= 18,
        clientEntrypoint: options.splitSources,
        dataEntrypoint: options.dataGeneration
    };
    if (options.kotlin) {
        return await generateKotlinEntrypoint(writer, classOptions);
    } else {
        return await generateJavaEntrypoint(writer, classOptions);
    }
}
function formatClassname(projectName) {
    return projectName.split(" ").map((s)=>s[0].toUpperCase() + s.slice(1)).join("").replace(/\W+/g, "");
}
async function generateJavaEntrypoint(writer, options) {
    var entrypoints = {
        "main": [
            options.classFullName
        ]
    };
    await writer.write(`src/main/java/${options.path}.java`, renderTemplate(javaEntrypointTemplate, options));
    if (options.clientEntrypoint) {
        await writer.write(`src/client/java/${options.path}Client.java`, renderTemplate(javaEntrypointClientTemplate, {
            ...options,
            className: options.className + "Client"
        }));
        entrypoints = {
            ...entrypoints,
            "client": [
                options.classFullName + "Client"
            ]
        };
    }
    if (options.dataEntrypoint) {
        await writer.write(`src/main/java/${options.path}DataGenerator.java`, renderTemplate(javaEntrypointDataGeneratorTemplate, {
            ...options,
            className: options.className + "DataGenerator"
        }));
        entrypoints = {
            ...entrypoints,
            "fabric-datagen": [
                options.classFullName + "DataGenerator"
            ]
        };
    }
    return entrypoints;
}
async function generateKotlinEntrypoint(writer, options) {
    var entrypoints = {
        "main": [
            {
                "value": options.classFullName,
                "adapter": "kotlin"
            }
        ]
    };
    await writer.write(`src/main/kotlin/${options.path}.kt`, renderTemplate(kotlinEntrypointTemplate, options));
    if (options.clientEntrypoint) {
        await writer.write(`src/client/kotlin/${options.path}Client.kt`, renderTemplate(kotlinEntrypointClientTemplate, {
            ...options,
            className: options.className + "Client"
        }));
        entrypoints = {
            ...entrypoints,
            "client": [
                {
                    "value": options.classFullName + "Client",
                    "adapter": "kotlin"
                }
            ]
        };
    }
    if (options.dataEntrypoint) {
        await writer.write(`src/main/kotlin/${options.path}DataGenerator.kt`, renderTemplate(kotlinEntrypointDataGeneratorTemplate, {
            ...options,
            className: options.className + "DataGenerator"
        }));
        entrypoints = {
            ...entrypoints,
            "fabric-datagen": [
                {
                    "value": options.classFullName + "DataGenerator",
                    "adapter": "kotlin"
                }
            ]
        };
    }
    return entrypoints;
}
function usesNewModid(fabricVersion) {
    return Number(fabricVersion.split(".")[1]) >= 59;
}
async function addModJson(writer, config) {
    var mixins = [
        ...await generateMixin(writer, config),
        ...config.splitSources ? await generateClientMixin(writer, config) : []
    ];
    var fabricModJson = {
        "schemaVersion": 1,
        "id": config.modid,
        "version": "${version}",
        "name": config.projectName,
        "description": "This is an example description! Tell everyone what your mod is about!",
        "authors": [
            "Me!"
        ],
        "contact": {
            "homepage": "https://fabricmc.net/",
            "sources": "https://github.com/FabricMC/fabric-example-mod"
        },
        "license": "CC0-1.0",
        "icon": `assets/${config.modid}/icon.png`,
        "environment": "*",
        "entrypoints": await generateEntrypoint(writer, config),
        "mixins": mixins,
        "depends": {
            "fabricloader": ">=" + config.loaderVersion,
            "minecraft": "~" + config.minecraftVersion,
            "java": ">=" + getJavaVersion(config.minecraftVersion).release
        },
        "suggests": {
            "another-mod": "*"
        }
    };
    fabricModJson.depends[usesNewModid(config.fabricVersion) ? "fabric-api" : "fabric"] = "*";
    if (config.kotlin) {
        fabricModJson.depends = {
            ...fabricModJson.depends,
            "fabric-language-kotlin": ">=" + config.kotlin.kotlinVersion
        };
    }
    await writer.write("src/main/resources/fabric.mod.json", JSON.stringify(fabricModJson, null, "	"));
    await writer.write(`src/main/resources/assets/${config.modid}/icon.png`, decode64(ICON));
}
const ICON = "iVBORw0KGgoAAAANSUhEUgAAAIAAAACAAQMAAAD58POIAAAABlBMVEUAAAD///+l2Z/dAAABeklEQVRIx9XTsW1cMQwGYAoKIlfWbaAVUroKbxSPcBtIQRaTN9EILFkI+l3ovXuSLvYZCK4wK+IrWBD/T1iGHg41fBUcygwWKY7QLGiCuoLaNoOY+1BnKFfQDUhnyGeZIZ3lNEO+LFBef01gyutlAlvOEzRb6MIDVCskDAD01MEJCTeKjWgHI1wp1A3Ui9Wg5HSHoFaDkN1BgroOzwN4ORkJuQNXX738NsKFAULpEI2wdIhAdRLTCM1JzBIHsMJZokSAkK/ApQMAbMADhCycDzASsoQObwDwR31Sn154AFJHpwPqT6NENACZOgIambYBNrCYAOSQflAcIEDCmPXEDyrQ42GP9wBuBXuAMqBENxBneCGegVNYIPsFygrqFqh2gXYDZoG+j5BuIC6QVyh8D444aPgXBKi/B9XtUD+ANkH9CsAuNz4D/wH8/Rx4gPZIsP8DDlAeHrRBXUFXkCugQ/YLUJhBiCeg3o8JsICdAKm38OhtGio2zveBd37Jm8IEWUmfAAAAAElFTkSuQmCC";
const license = `Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.`;
async function addGitFiles(writer, _config) {
    await writer.write(".gitignore", gitignore);
    await writer.write(".github/workflows/build.yml", workflow);
    await writer.write("LICENSE", license);
}
async function generateTemplate(options) {
    const computedConfig = await computeConfig(options.config);
    await addGradleWrapper(options);
    await addGroovyGradle(options.writer, computedConfig);
    await addModJson(options.writer, computedConfig);
    await addGitFiles(options.writer);
}
async function getTemplateGameVersions() {
    let versions = await getGameVersions();
    return versions.filter((v)=>v.stable).filter((v)=>{
        const version = v.version;
        if (version.startsWith("1.14") && version != "1.14.4") {
            return false;
        }
        return true;
    });
}
async function computeConfig(options) {
    return {
        ...options,
        loaderVersion: (await getLoaderVersions()).find((v)=>v.stable).version,
        fabricVersion: await getApiVersionForMinecraft(options.minecraftVersion),
        yarnVersion: (await getMinecraftYarnVersions(options.minecraftVersion))[0].version,
        kotlin: await computeKotlinOptions(options)
    };
}
async function computeKotlinOptions(options) {
    if (!options.useKotlin) {
        return void 0;
    }
    const kotlinVersions = await getKotlinAdapterVersions();
    const fabricKotlinAdapterVersion = kotlinVersions.pop();
    const kotlinVersion = fabricKotlinAdapterVersion.split("+kotlin.")[1];
    return {
        fabricKotlinAdapterVersion,
        kotlinVersion
    };
}
const $XML = Symbol("x/xml");
const schema = {
    comment: "#comment",
    text: "#text",
    stylesheets: "$stylesheets",
    attribute: {
        prefix: "@"
    },
    property: {
        prefix: "@"
    },
    space: {
        name: "xml:space",
        preserve: "preserve"
    }
};
const SeekMode = Object.freeze({
    Current: Deno?.SeekMode?.Current ?? 0,
    Start: Deno?.SeekMode?.Start ?? 1,
    End: Deno?.SeekMode?.End ?? 2
});
const entities = {
    xml: {
        "&lt;": "<",
        "&gt;": ">",
        "&apos;": "'",
        "&quot;": '"',
        "&amp;": "&"
    },
    char: {
        "&": "&amp;",
        '"': "&quot;",
        "<": "&lt;",
        ">": "&gt;",
        "'": "&apos;"
    }
};
const tokens = {
    entity: {
        regex: {
            entities: /&#(?<hex>x?)(?<code>\d+);/g
        }
    },
    prolog: {
        start: "<?xml",
        end: "?>"
    },
    stylesheet: {
        start: "<?xml-stylesheet",
        end: "?>"
    },
    doctype: {
        start: "<!DOCTYPE",
        end: ">",
        elements: {
            start: "[",
            end: "]"
        },
        element: {
            start: "<!ELEMENT",
            end: ">",
            value: {
                start: "(",
                end: ")",
                regex: {
                    end: {
                        until: /\)/,
                        bytes: 1
                    }
                }
            }
        }
    },
    comment: {
        start: "<!--",
        end: "-->",
        regex: {
            end: {
                until: /(?<!-)-->/,
                bytes: 4,
                length: 3
            }
        }
    },
    cdata: {
        start: "<![CDATA[",
        end: "]]>",
        regex: {
            end: {
                until: /\]\]>/,
                bytes: 3
            }
        }
    },
    tag: {
        start: "<",
        end: ">",
        close: {
            start: "</",
            end: ">",
            self: "/",
            regex: {
                start: /<\//,
                end: /\/?>/
            }
        },
        attribute: {
            regex: {
                name: {
                    until: /=/,
                    bytes: 1
                }
            }
        },
        regex: {
            name: {
                until: /[\s\/>]/,
                bytes: 1
            },
            start: {
                until: /</,
                bytes: 1
            }
        }
    },
    text: {
        regex: {
            end: {
                until: /(<\/)|(<!)/,
                bytes: 2
            }
        }
    }
};
class Parser {
    constructor(stream, options = {}){
        this.#stream = stream;
        this.#options = options;
        this.#options.reviver ??= function({ value  }) {
            return value;
        };
    }
    parse() {
        return this.#document();
    }
    #options;
    #debug(path, string) {
        if (this.#options.debug) {
            console.debug(`${path.map((node)=>node[$XML].name).join(" > ")} | ${string}`.trim());
        }
    }
    #document() {
        const document = Object.defineProperty({}, $XML, {
            enumerable: false,
            writable: true,
            value: {
                cdata: []
            }
        });
        const path = [];
        const comments = [];
        let root = false;
        let clean;
        this.#trim();
        try {
            while(true){
                clean = true;
                if (this.#peek(tokens.comment.start)) {
                    clean = false;
                    comments.push(this.#comment({
                        path
                    }));
                    continue;
                }
                if (this.#peek(tokens.prolog.start) && !this.#peek(tokens.stylesheet.start)) {
                    if (document.xml) {
                        throw Object.assign(new SyntaxError("Multiple prolog declaration found"), {
                            stack: false
                        });
                    }
                    clean = false;
                    Object.assign(document, this.#prolog({
                        path
                    }));
                    continue;
                }
                if (this.#peek(tokens.stylesheet.start)) {
                    clean = false;
                    const stylesheets = document[schema.stylesheets] ??= [];
                    stylesheets.push(this.#stylesheet({
                        path
                    }).stylesheet);
                    continue;
                }
                if (this.#peek(tokens.doctype.start)) {
                    if (document.doctype) {
                        throw Object.assign(new SyntaxError("Multiple doctype declaration found"), {
                            stack: false
                        });
                    }
                    clean = false;
                    Object.assign(document, this.#doctype({
                        path
                    }));
                    continue;
                }
                if (this.#peek(tokens.tag.start)) {
                    if (root) {
                        throw Object.assign(new SyntaxError("Multiple root elements found"), {
                            stack: false
                        });
                    }
                    clean = false;
                    Object.assign(document, this.#node({
                        document,
                        path
                    }));
                    this.#trim();
                    root = true;
                    continue;
                }
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof && clean) {
                if (comments.length) {
                    document[schema.comment] = comments;
                }
                return document;
            }
            throw error;
        }
    }
    #node({ document , path  }) {
        if (this.#options.progress) {
            this.#options.progress(this.#stream.cursor);
        }
        if (this.#peek(tokens.comment.start)) {
            return {
                [schema.comment]: this.#comment({
                    path
                })
            };
        }
        return this.#tag({
            document,
            path
        });
    }
    #prolog({ path  }) {
        this.#debug(path, "parsing prolog");
        const prolog = this.#make.node({
            name: "xml",
            path
        });
        this.#consume(tokens.prolog.start);
        while(!this.#peek(tokens.prolog.end)){
            Object.assign(prolog, this.#attribute({
                path: [
                    ...path,
                    prolog
                ]
            }));
        }
        this.#consume(tokens.prolog.end);
        return {
            xml: prolog
        };
    }
    #stylesheet({ path  }) {
        this.#debug(path, "parsing stylesheet");
        const stylesheet = this.#make.node({
            name: "xml-stylesheet",
            path
        });
        this.#consume(tokens.stylesheet.start);
        while(!this.#peek(tokens.stylesheet.end)){
            Object.assign(stylesheet, this.#attribute({
                path: [
                    ...path,
                    stylesheet
                ]
            }));
        }
        this.#consume(tokens.stylesheet.end);
        return {
            stylesheet
        };
    }
    #doctype({ path  }) {
        this.#debug(path, "parsing doctype");
        const doctype = this.#make.node({
            name: "doctype",
            path
        });
        Object.defineProperty(doctype, $XML, {
            enumerable: false,
            writable: true
        });
        this.#consume(tokens.doctype.start);
        while(!this.#peek(tokens.doctype.end)){
            if (this.#peek(tokens.doctype.elements.start)) {
                this.#consume(tokens.doctype.elements.start);
                while(!this.#peek(tokens.doctype.elements.end)){
                    Object.assign(doctype, this.#doctypeElement({
                        path
                    }));
                }
                this.#consume(tokens.doctype.elements.end);
            } else {
                Object.assign(doctype, this.#property({
                    path
                }));
            }
        }
        this.#stream.consume({
            content: tokens.doctype.end
        });
        return {
            doctype
        };
    }
    #doctypeElement({ path  }) {
        this.#debug(path, "parsing doctype element");
        this.#consume(tokens.doctype.element.start);
        const element = Object.keys(this.#property({
            path
        })).shift().substring(schema.property.prefix.length);
        this.#debug(path, `found doctype element "${element}"`);
        this.#consume(tokens.doctype.element.value.start);
        const value = this.#capture(tokens.doctype.element.value.regex.end);
        this.#consume(tokens.doctype.element.value.end);
        this.#debug(path, `found doctype element value "${value}"`);
        this.#consume(tokens.doctype.element.end);
        return {
            [element]: value
        };
    }
    #tag({ document , path  }) {
        this.#debug(path, "parsing tag");
        const tag = this.#make.node({
            path
        });
        this.#consume(tokens.tag.start);
        const name = this.#capture(tokens.tag.regex.name);
        Object.assign(tag[$XML], {
            name
        });
        this.#debug(path, `found tag "${name}"`);
        while(!tokens.tag.close.regex.end.test(this.#stream.peek(2))){
            Object.assign(tag, this.#attribute({
                path: [
                    ...path,
                    tag
                ]
            }));
        }
        let trim = true;
        if (tag[`${schema.attribute.prefix}${schema.space.name}`] === schema.space.preserve) {
            this.#debug([
                ...path,
                tag
            ], `${schema.space.name} is set to ${schema.space.preserve}`);
            trim = false;
        }
        const selfclosed = this.#peek(tokens.tag.close.self);
        if (selfclosed) {
            this.#debug(path, `tag "${name}" is self-closed`);
            this.#consume(tokens.tag.close.self);
        }
        this.#consume(tokens.tag.end, {
            trim
        });
        if (!selfclosed) {
            if (this.#peek(tokens.cdata.start) || !this.#peek(tokens.tag.start)) {
                Object.assign(tag, this.#text({
                    document,
                    close: name,
                    path: [
                        ...path,
                        tag
                    ],
                    trim
                }));
            } else {
                while(!tokens.tag.close.regex.start.test(this.#stream.peek(2))){
                    const child = this.#node({
                        document,
                        path: [
                            ...path,
                            tag
                        ]
                    });
                    const [key, value] = Object.entries(child).shift();
                    if (Array.isArray(tag[key])) {
                        tag[key].push(value);
                        this.#debug([
                            ...path,
                            tag
                        ], `add new child "${key}" to array`);
                    } else if (key in tag) {
                        const array = [
                            tag[key],
                            value
                        ];
                        Object.defineProperty(array, $XML, {
                            enumerable: false,
                            writable: true
                        });
                        if (tag[key]?.[$XML]) {
                            Object.assign(array, {
                                [$XML]: tag[key][$XML]
                            });
                        }
                        tag[key] = array;
                        this.#debug([
                            ...path,
                            tag
                        ], `multiple children named "${key}", using array notation`);
                    } else {
                        Object.assign(tag, child);
                        this.#debug([
                            ...path,
                            tag
                        ], `add new child "${key}"`);
                    }
                }
            }
            this.#consume(tokens.tag.close.start);
            this.#consume(name);
            this.#consume(tokens.tag.close.end);
            this.#debug(path, `found closing tag for "${name}"`);
        }
        for (const [key] of Object.entries(tag).filter(([_, value])=>typeof value === "undefined")){
            delete tag[key];
        }
        if (!Object.keys(tag).includes(schema.text)) {
            const children = Object.keys(tag).filter((key)=>!key.startsWith(schema.attribute.prefix) && key !== schema.text);
            if (!children.length) {
                this.#debug(path, `tag "${name}" has implictely obtained a text node as it has no children but has attributes`);
                tag[schema.text] = this.#revive({
                    key: schema.text,
                    value: "",
                    tag
                });
            }
        }
        if ((this.#options.flatten ?? true) && Object.keys(tag).includes(schema.text) && Object.keys(tag).length === 1) {
            this.#debug(path, `tag "${name}" has been implicitely flattened as it only has a text node`);
            return {
                [name]: tag[schema.text]
            };
        }
        return {
            [name]: tag
        };
    }
    #attribute({ path  }) {
        this.#debug(path, "parsing attribute");
        const attribute = this.#capture(tokens.tag.attribute.regex.name);
        this.#debug(path, `found attribute "${attribute}"`);
        this.#consume("=");
        const quote = this.#stream.peek();
        this.#consume(quote);
        const value = this.#capture({
            until: new RegExp(quote),
            bytes: quote.length
        });
        this.#consume(quote);
        this.#debug(path, `found attribute value "${value}"`);
        return {
            [`${schema.attribute.prefix}${attribute}`]: this.#revive({
                key: `${schema.attribute.prefix}${attribute}`,
                value,
                tag: path.at(-1)
            })
        };
    }
    #property({ path  }) {
        this.#debug(path, "parsing property");
        const quote = this.#stream.peek();
        const delimiter = /["']/.test(quote) ? quote : " ";
        if (delimiter.trim().length) {
            this.#consume(delimiter);
        }
        const property = this.#capture({
            until: new RegExp(delimiter),
            bytes: delimiter.length
        });
        this.#debug(path, `found property ${property}`);
        if (delimiter.trim().length) {
            this.#consume(delimiter);
        }
        return {
            [`${schema.property.prefix}${property}`]: true
        };
    }
    #text({ document , close , path , trim  }) {
        this.#debug(path, "parsing text");
        const tag = this.#make.node({
            name: schema.text,
            path
        });
        let text = "";
        const comments = [];
        while(this.#peek(tokens.cdata.start) || !this.#peeks([
            tokens.tag.close.start,
            close,
            tokens.tag.close.end
        ])){
            if (this.#peek(tokens.cdata.start)) {
                const cpath = path.map((node)=>node[$XML].name);
                document[$XML].cdata?.push(cpath);
                this.#debug(path, `text is specified as cdata, storing path >${cpath.join(">")} in document metadata`);
                text += this.#cdata({
                    path: [
                        ...path,
                        tag
                    ]
                });
            } else if (this.#peek(tokens.comment.start)) {
                comments.push(this.#comment({
                    path: [
                        ...path,
                        tag
                    ]
                }));
            } else {
                text += this.#capture({
                    ...tokens.text.regex.end
                }, {
                    trim
                });
                if (this.#peek(tokens.cdata.start) || this.#peek(tokens.comment.start)) {
                    continue;
                }
                if (!this.#peeks([
                    tokens.tag.close.start,
                    close,
                    tokens.tag.close.end
                ])) {
                    text += tokens.tag.close.start;
                    this.#consume(tokens.tag.close.start);
                }
            }
        }
        this.#debug(path, `parsed text "${text}"`);
        if (comments.length) {
            this.#debug(path, `parsed comments ${JSON.stringify(comments)}`);
        }
        Object.assign(tag, {
            [schema.text]: this.#revive({
                key: schema.text,
                value: trim ? text.trim() : text,
                tag: path.at(-1)
            }),
            ...comments.length ? {
                [schema.comment]: comments
            } : {}
        });
        return tag;
    }
    #cdata({ path  }) {
        this.#debug(path, "parsing cdata");
        this.#consume(tokens.cdata.start);
        const data = this.#capture(tokens.cdata.regex.end);
        this.#consume(tokens.cdata.end);
        return data;
    }
    #comment({ path  }) {
        this.#debug(path, "parsing comment");
        this.#consume(tokens.comment.start);
        const comment = this.#capture(tokens.comment.regex.end).trim();
        this.#consume(tokens.comment.end);
        return comment;
    }
    #revive({ key , value , tag  }) {
        return this.#options.reviver.call(tag, {
            key,
            tag: tag[$XML].name,
            properties: !(key.startsWith(schema.attribute.prefix) || key.startsWith(schema.property.prefix)) ? {
                ...tag
            } : null,
            value: (()=>{
                switch(true){
                    case (this.#options.emptyToNull ?? true) && /^\s*$/.test(value):
                        return null;
                    case (this.#options.reviveBooleans ?? true) && /^(?:true|false)$/i.test(value):
                        return /^true$/i.test(value);
                    case this.#options.reviveNumbers ?? true:
                        {
                            const num = Number(value);
                            if (Number.isFinite(num)) {
                                return num;
                            }
                        }
                    default:
                        value = value.replace(tokens.entity.regex.entities, (_, hex, code)=>String.fromCharCode(parseInt(code, hex ? 16 : 10)));
                        for (const [entity, character] of Object.entries(entities.xml)){
                            value = value.replaceAll(entity, character);
                        }
                        return value;
                }
            })()
        });
    }
    #make = {
        node ({ name ="" , path =[]  }) {
            const node = {
                [$XML]: {
                    name,
                    parent: path[path.length - 1] ?? null
                }
            };
            Object.defineProperty(node, $XML, {
                enumerable: false,
                writable: true
            });
            return node;
        }
    };
    #stream;
    #peek(token) {
        return this.#stream.peek(token.length) === token;
    }
    #peeks(tokens) {
        let offset = 0;
        for(let i = 0; i < tokens.length; i++){
            const token = tokens[i];
            while(true){
                if (/\s/.test(this.#stream.peek(1, offset))) {
                    offset++;
                    continue;
                }
                if (this.#stream.peek(token.length, offset) === token) {
                    offset += token.length;
                    break;
                }
                return false;
            }
        }
        return true;
    }
    #consume(token, { trim  } = {}) {
        return this.#stream.consume({
            content: token,
            trim
        });
    }
    #capture(token, { trim  } = {}) {
        return this.#stream.capture({
            ...token,
            trim
        });
    }
    #trim() {
        return this.#stream.trim();
    }
}
class Stream {
    constructor(content){
        this.#content = content;
    }
    #decoder = new TextDecoder();
    #encoder = new TextEncoder();
    #content;
    get cursor() {
        return this.#content.seekSync(0, SeekMode.Current);
    }
    peek(bytes = 1, offset = 0) {
        const buffer = new Uint8Array(bytes);
        const cursor = this.cursor;
        if (offset) {
            this.#content.seekSync(offset, SeekMode.Current);
        }
        if (this.#content.readSync(buffer)) {
            this.#content.seekSync(cursor, SeekMode.Start);
            return this.#decoder.decode(buffer);
        }
        throw new Deno.errors.UnexpectedEof();
    }
    read(bytes = 1) {
        const buffer = new Uint8Array(bytes);
        if (this.#content.readSync(buffer)) {
            return buffer;
        }
        throw new Deno.errors.UnexpectedEof();
    }
    capture({ until , bytes , trim =true , length =bytes  }) {
        if (trim) {
            this.trim();
        }
        const buffer = [];
        while(!until.test(this.peek(bytes))){
            buffer.push(this.read(1)[0]);
        }
        if (bytes !== length) {
            buffer.push(...this.read(bytes - length));
        }
        if (trim) {
            this.trim();
        }
        return this.#decoder.decode(Uint8Array.from(buffer));
    }
    consume({ content , trim =true  }) {
        if (trim) {
            this.trim();
        }
        const bytes = this.#encoder.encode(content).length;
        if (content === this.peek(bytes)) {
            this.read(bytes);
            if (trim) {
                this.trim();
            }
            return;
        }
        throw Object.assign(new SyntaxError(`Expected next sequence to be "${content}", got "${this.peek(bytes)}" instead`), {
            stack: false
        });
    }
    trim() {
        try {
            while(/\s/.test(this.peek())){
                this.read(1);
            }
        } catch (error) {
            if (error instanceof Deno.errors.UnexpectedEof) {
                return;
            }
            throw error;
        }
    }
}
class Streamable {
    constructor(string){
        this.#buffer = new TextEncoder().encode(string);
    }
    #buffer;
    #cursor = 0;
    readSync(buffer) {
        const bytes = this.#buffer.slice(this.#cursor, this.#cursor + buffer.length);
        buffer.set(bytes);
        this.#cursor = Math.min(this.#cursor + bytes.length, this.#buffer.length);
        return bytes.length || null;
    }
    seekSync(offset, whence) {
        switch(whence){
            case SeekMode.Start:
                this.#cursor = offset;
                break;
            case SeekMode.Current:
                this.#cursor += offset;
                break;
            case SeekMode.End:
                this.#cursor = this.#buffer.length + offset;
                break;
        }
        return this.#cursor;
    }
}
function parse(content, options) {
    if (typeof content === "string") {
        content = new Streamable(content);
    }
    return new Parser(new Stream(content), options).parse();
}
function distance(a, b) {
    if (a.length == 0) {
        return b.length;
    }
    if (b.length == 0) {
        return a.length;
    }
    const matrix = [];
    for(let i = 0; i <= b.length; i++){
        matrix[i] = [
            i
        ];
    }
    for(let j = 0; j <= a.length; j++){
        matrix[0][j] = j;
    }
    for(let i = 1; i <= b.length; i++){
        for(let j = 1; j <= a.length; j++){
            if (b.charAt(i - 1) == a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            }
        }
    }
    return matrix[b.length][a.length];
}
function paramCaseToCamelCase(str) {
    return str.replace(/-([a-z])/g, (g)=>g[1].toUpperCase());
}
function underscoreToCamelCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(/_([a-z])/g, (g)=>g[1].toUpperCase());
}
function getOption(flags, name) {
    while(name[0] === "-"){
        name = name.slice(1);
    }
    for (const flag of flags){
        if (isOption(flag, name)) {
            return flag;
        }
    }
    return;
}
function didYouMeanOption(option, options) {
    const optionNames = options.map((option)=>[
            option.name,
            ...option.aliases ?? []
        ]).flat().map((option)=>getFlag(option));
    return didYouMean(" Did you mean option", getFlag(option), optionNames);
}
function didYouMeanType(type, types) {
    return didYouMean(" Did you mean type", type, types);
}
function didYouMean(message, type, types) {
    const match = closest(type, types);
    return match ? `${message} "${match}"?` : "";
}
function getFlag(name) {
    if (name.startsWith("-")) {
        return name;
    }
    if (name.length > 1) {
        return `--${name}`;
    }
    return `-${name}`;
}
function isOption(option, name) {
    return option.name === name || option.aliases && option.aliases.indexOf(name) !== -1;
}
function matchWildCardOptions(name, flags) {
    for (const option of flags){
        if (option.name.indexOf("*") === -1) {
            continue;
        }
        let matched = matchWildCardOption(name, option);
        if (matched) {
            matched = {
                ...matched,
                name
            };
            flags.push(matched);
            return matched;
        }
    }
}
function matchWildCardOption(name, option) {
    const parts = option.name.split(".");
    const parts2 = name.split(".");
    if (parts.length !== parts2.length) {
        return false;
    }
    const count = Math.max(parts.length, parts2.length);
    for(let i = 0; i < count; i++){
        if (parts[i] !== parts2[i] && parts[i] !== "*") {
            return false;
        }
    }
    return option;
}
function closest(str, arr) {
    let minDistance = Infinity;
    let minIndex = 0;
    for(let i = 0; i < arr.length; i++){
        const dist = distance(str, arr[i]);
        if (dist < minDistance) {
            minDistance = dist;
            minIndex = i;
        }
    }
    return arr[minIndex];
}
function getDefaultValue(option) {
    return typeof option.default === "function" ? option.default() : option.default;
}
class FlagsError extends Error {
    constructor(message){
        super(message);
        Object.setPrototypeOf(this, FlagsError.prototype);
    }
}
class UnknownRequiredOptionError extends FlagsError {
    constructor(option, options){
        super(`Unknown required option "${getFlag(option)}".${didYouMeanOption(option, options)}`);
        Object.setPrototypeOf(this, UnknownRequiredOptionError.prototype);
    }
}
class UnknownConflictingOptionError extends FlagsError {
    constructor(option, options){
        super(`Unknown conflicting option "${getFlag(option)}".${didYouMeanOption(option, options)}`);
        Object.setPrototypeOf(this, UnknownConflictingOptionError.prototype);
    }
}
class UnknownTypeError extends FlagsError {
    constructor(type, types){
        super(`Unknown type "${type}".${didYouMeanType(type, types)}`);
        Object.setPrototypeOf(this, UnknownTypeError.prototype);
    }
}
class ValidationError extends FlagsError {
    constructor(message){
        super(message);
        Object.setPrototypeOf(this, ValidationError.prototype);
    }
}
class DuplicateOptionError extends ValidationError {
    constructor(name){
        super(`Option "${getFlag(name).replace(/^--no-/, "--")}" can only occur once, but was found several times.`);
        Object.setPrototypeOf(this, DuplicateOptionError.prototype);
    }
}
class InvalidOptionError extends ValidationError {
    constructor(option, options){
        super(`Invalid option "${getFlag(option)}".${didYouMeanOption(option, options)}`);
        Object.setPrototypeOf(this, InvalidOptionError.prototype);
    }
}
class UnknownOptionError extends ValidationError {
    constructor(option, options){
        super(`Unknown option "${getFlag(option)}".${didYouMeanOption(option, options)}`);
        Object.setPrototypeOf(this, UnknownOptionError.prototype);
    }
}
class MissingOptionValueError extends ValidationError {
    constructor(option){
        super(`Missing value for option "${getFlag(option)}".`);
        Object.setPrototypeOf(this, MissingOptionValueError.prototype);
    }
}
class InvalidOptionValueError extends ValidationError {
    constructor(option, expected, value){
        super(`Option "${getFlag(option)}" must be of type "${expected}", but got "${value}".`);
        Object.setPrototypeOf(this, InvalidOptionValueError.prototype);
    }
}
class UnexpectedOptionValueError extends ValidationError {
    constructor(option, value){
        super(`Option "${getFlag(option)}" doesn't take a value, but got "${value}".`);
        Object.setPrototypeOf(this, InvalidOptionValueError.prototype);
    }
}
class OptionNotCombinableError extends ValidationError {
    constructor(option){
        super(`Option "${getFlag(option)}" cannot be combined with other options.`);
        Object.setPrototypeOf(this, OptionNotCombinableError.prototype);
    }
}
class ConflictingOptionError extends ValidationError {
    constructor(option, conflictingOption){
        super(`Option "${getFlag(option)}" conflicts with option "${getFlag(conflictingOption)}".`);
        Object.setPrototypeOf(this, ConflictingOptionError.prototype);
    }
}
class DependingOptionError extends ValidationError {
    constructor(option, dependingOption){
        super(`Option "${getFlag(option)}" depends on option "${getFlag(dependingOption)}".`);
        Object.setPrototypeOf(this, DependingOptionError.prototype);
    }
}
class MissingRequiredOptionError extends ValidationError {
    constructor(option){
        super(`Missing required option "${getFlag(option)}".`);
        Object.setPrototypeOf(this, MissingRequiredOptionError.prototype);
    }
}
class UnexpectedRequiredArgumentError extends ValidationError {
    constructor(arg){
        super(`An required argument cannot follow an optional argument, but "${arg}"  is defined as required.`);
        Object.setPrototypeOf(this, UnexpectedRequiredArgumentError.prototype);
    }
}
class UnexpectedArgumentAfterVariadicArgumentError extends ValidationError {
    constructor(arg){
        super(`An argument cannot follow an variadic argument, but got "${arg}".`);
        Object.setPrototypeOf(this, UnexpectedArgumentAfterVariadicArgumentError.prototype);
    }
}
class InvalidTypeError extends ValidationError {
    constructor({ label , name , value , type  }, expected){
        super(`${label} "${name}" must be of type "${type}", but got "${value}".` + (expected ? ` Expected values: ${expected.map((value)=>`"${value}"`).join(", ")}` : ""));
        Object.setPrototypeOf(this, MissingOptionValueError.prototype);
    }
}
var OptionType;
(function(OptionType) {
    OptionType["STRING"] = "string";
    OptionType["NUMBER"] = "number";
    OptionType["INTEGER"] = "integer";
    OptionType["BOOLEAN"] = "boolean";
})(OptionType || (OptionType = {}));
function didYouMeanCommand(command, commands, excludes = []) {
    const commandNames = commands.map((command)=>command.getName()).filter((command)=>!excludes.includes(command));
    return didYouMean(" Did you mean command", command, commandNames);
}
const ARGUMENT_REGEX = /^[<\[].+[\]>]$/;
const ARGUMENT_DETAILS_REGEX = /[<\[:>\]]/;
function splitArguments(args) {
    const parts = args.trim().split(/[, =] */g);
    const typeParts = [];
    while(parts[parts.length - 1] && ARGUMENT_REGEX.test(parts[parts.length - 1])){
        typeParts.unshift(parts.pop());
    }
    const typeDefinition = typeParts.join(" ");
    return {
        flags: parts,
        typeDefinition,
        equalsSign: args.includes("=")
    };
}
function parseArgumentsDefinition(argsDefinition, validate = true, all) {
    const argumentDetails = [];
    let hasOptional = false;
    let hasVariadic = false;
    const parts = argsDefinition.split(/ +/);
    for (const arg of parts){
        if (validate && hasVariadic) {
            throw new UnexpectedArgumentAfterVariadicArgumentError(arg);
        }
        const parts = arg.split(ARGUMENT_DETAILS_REGEX);
        if (!parts[1]) {
            if (all) {
                argumentDetails.push(parts[0]);
            }
            continue;
        }
        const type = parts[2] || OptionType.STRING;
        const details = {
            optionalValue: arg[0] === "[",
            requiredValue: arg[0] === "<",
            name: parts[1],
            action: parts[3] || type,
            variadic: false,
            list: type ? arg.indexOf(type + "[]") !== -1 : false,
            type
        };
        if (validate && !details.optionalValue && hasOptional) {
            throw new UnexpectedRequiredArgumentError(details.name);
        }
        if (arg[0] === "[") {
            hasOptional = true;
        }
        if (details.name.length > 3) {
            const istVariadicLeft = details.name.slice(0, 3) === "...";
            const istVariadicRight = details.name.slice(-3) === "...";
            hasVariadic = details.variadic = istVariadicLeft || istVariadicRight;
            if (istVariadicLeft) {
                details.name = details.name.slice(3);
            } else if (istVariadicRight) {
                details.name = details.name.slice(0, -3);
            }
        }
        argumentDetails.push(details);
    }
    return argumentDetails;
}
function dedent(str) {
    const lines = str.split(/\r?\n|\r/g);
    let text = "";
    let indent = 0;
    for (const line of lines){
        if (text || line.trim()) {
            if (!text) {
                text = line.trimStart();
                indent = line.length - text.length;
            } else {
                text += line.slice(indent);
            }
            text += "\n";
        }
    }
    return text.trimEnd();
}
function getDescription(description, __short) {
    return __short ? description.trim().split("\n", 1)[0].trim() : dedent(description);
}
class CommandError extends Error {
    constructor(message){
        super(message);
        Object.setPrototypeOf(this, CommandError.prototype);
    }
}
class ValidationError1 extends CommandError {
    exitCode;
    cmd;
    constructor(message, { exitCode  } = {}){
        super(message);
        Object.setPrototypeOf(this, ValidationError1.prototype);
        this.exitCode = exitCode ?? 1;
    }
}
class DuplicateOptionNameError extends CommandError {
    constructor(name){
        super(`Option with name "${getFlag(name)}" already exists.`);
        Object.setPrototypeOf(this, DuplicateOptionNameError.prototype);
    }
}
class MissingCommandNameError extends CommandError {
    constructor(){
        super("Missing command name.");
        Object.setPrototypeOf(this, MissingCommandNameError.prototype);
    }
}
class DuplicateCommandNameError extends CommandError {
    constructor(name){
        super(`Duplicate command name "${name}".`);
        Object.setPrototypeOf(this, DuplicateCommandNameError.prototype);
    }
}
class DuplicateCommandAliasError extends CommandError {
    constructor(alias){
        super(`Duplicate command alias "${alias}".`);
        Object.setPrototypeOf(this, DuplicateCommandAliasError.prototype);
    }
}
class CommandNotFoundError extends CommandError {
    constructor(name, commands, excluded){
        super(`Unknown command "${name}".${didYouMeanCommand(name, commands, excluded)}`);
        Object.setPrototypeOf(this, CommandNotFoundError.prototype);
    }
}
class DuplicateTypeError extends CommandError {
    constructor(name){
        super(`Type with name "${name}" already exists.`);
        Object.setPrototypeOf(this, DuplicateTypeError.prototype);
    }
}
class DuplicateCompletionError extends CommandError {
    constructor(name){
        super(`Completion with name "${name}" already exists.`);
        Object.setPrototypeOf(this, DuplicateCompletionError.prototype);
    }
}
class DuplicateExampleError extends CommandError {
    constructor(name){
        super(`Example with name "${name}" already exists.`);
        Object.setPrototypeOf(this, DuplicateExampleError.prototype);
    }
}
class DuplicateEnvVarError extends CommandError {
    constructor(name){
        super(`Environment variable with name "${name}" already exists.`);
        Object.setPrototypeOf(this, DuplicateEnvVarError.prototype);
    }
}
class MissingRequiredEnvVarError extends ValidationError1 {
    constructor(envVar){
        super(`Missing required environment variable "${envVar.names[0]}".`);
        Object.setPrototypeOf(this, MissingRequiredEnvVarError.prototype);
    }
}
class TooManyEnvVarValuesError extends CommandError {
    constructor(name){
        super(`An environment variable can only have one value, but "${name}" has more than one.`);
        Object.setPrototypeOf(this, TooManyEnvVarValuesError.prototype);
    }
}
class UnexpectedOptionalEnvVarValueError extends CommandError {
    constructor(name){
        super(`An environment variable cannot have an optional value, but "${name}" is defined as optional.`);
        Object.setPrototypeOf(this, UnexpectedOptionalEnvVarValueError.prototype);
    }
}
class UnexpectedVariadicEnvVarValueError extends CommandError {
    constructor(name){
        super(`An environment variable cannot have an variadic value, but "${name}" is defined as variadic.`);
        Object.setPrototypeOf(this, UnexpectedVariadicEnvVarValueError.prototype);
    }
}
class DefaultCommandNotFoundError extends CommandError {
    constructor(name, commands){
        super(`Default command "${name}" not found.${didYouMeanCommand(name, commands)}`);
        Object.setPrototypeOf(this, DefaultCommandNotFoundError.prototype);
    }
}
class CommandExecutableNotFoundError extends CommandError {
    constructor(name){
        super(`Command executable not found: ${name}`);
        Object.setPrototypeOf(this, CommandExecutableNotFoundError.prototype);
    }
}
class UnknownCompletionCommandError extends CommandError {
    constructor(name, commands){
        super(`Auto-completion failed. Unknown command "${name}".${didYouMeanCommand(name, commands)}`);
        Object.setPrototypeOf(this, UnknownCompletionCommandError.prototype);
    }
}
class UnknownCommandError extends ValidationError1 {
    constructor(name, commands, excluded){
        super(`Unknown command "${name}".${didYouMeanCommand(name, commands, excluded)}`);
        Object.setPrototypeOf(this, UnknownCommandError.prototype);
    }
}
class NoArgumentsAllowedError extends ValidationError1 {
    constructor(name){
        super(`No arguments allowed for command "${name}".`);
        Object.setPrototypeOf(this, NoArgumentsAllowedError.prototype);
    }
}
class MissingArgumentsError extends ValidationError1 {
    constructor(names){
        super(`Missing argument(s): ${names.join(", ")}`);
        Object.setPrototypeOf(this, MissingArgumentsError.prototype);
    }
}
class MissingArgumentError extends ValidationError1 {
    constructor(name){
        super(`Missing argument: ${name}`);
        Object.setPrototypeOf(this, MissingArgumentError.prototype);
    }
}
class TooManyArgumentsError extends ValidationError1 {
    constructor(args){
        super(`Too many arguments: ${args.join(" ")}`);
        Object.setPrototypeOf(this, TooManyArgumentsError.prototype);
    }
}
const __boolean = (type)=>{
    if (~[
        "1",
        "true"
    ].indexOf(type.value)) {
        return true;
    }
    if (~[
        "0",
        "false"
    ].indexOf(type.value)) {
        return false;
    }
    throw new InvalidTypeError(type, [
        "true",
        "false",
        "1",
        "0"
    ]);
};
const number = (type)=>{
    const value = Number(type.value);
    if (Number.isFinite(value)) {
        return value;
    }
    throw new InvalidTypeError(type);
};
const string = ({ value  })=>{
    return value;
};
function validateFlags(ctx, opts, options = new Map()) {
    if (!opts.flags) {
        return;
    }
    const defaultValues = setDefaultValues(ctx, opts);
    const optionNames = Object.keys(ctx.flags);
    if (!optionNames.length && opts.allowEmpty) {
        return;
    }
    if (ctx.standalone) {
        validateStandaloneOption(ctx, options, optionNames, defaultValues);
        return;
    }
    for (const [name, option] of options){
        validateUnknownOption(option, opts);
        validateConflictingOptions(ctx, option);
        validateDependingOptions(ctx, option, defaultValues);
        validateRequiredValues(ctx, option, name);
    }
    validateRequiredOptions(ctx, options, opts);
}
function validateUnknownOption(option, opts) {
    if (!getOption(opts.flags ?? [], option.name)) {
        throw new UnknownOptionError(option.name, opts.flags ?? []);
    }
}
function setDefaultValues(ctx, opts) {
    const defaultValues = {};
    if (!opts.flags?.length) {
        return defaultValues;
    }
    for (const option of opts.flags){
        let name;
        let defaultValue = undefined;
        if (option.name.startsWith("no-")) {
            const propName = option.name.replace(/^no-/, "");
            if (typeof ctx.flags[propName] !== "undefined") {
                continue;
            }
            const positiveOption = getOption(opts.flags, propName);
            if (positiveOption) {
                continue;
            }
            name = paramCaseToCamelCase(propName);
            defaultValue = true;
        }
        if (!name) {
            name = paramCaseToCamelCase(option.name);
        }
        const hasDefaultValue = (!opts.ignoreDefaults || typeof opts.ignoreDefaults[name] === "undefined") && typeof ctx.flags[name] === "undefined" && (typeof option.default !== "undefined" || typeof defaultValue !== "undefined");
        if (hasDefaultValue) {
            ctx.flags[name] = getDefaultValue(option) ?? defaultValue;
            defaultValues[option.name] = true;
            if (typeof option.value === "function") {
                ctx.flags[name] = option.value(ctx.flags[name]);
            }
        }
    }
    return defaultValues;
}
function validateStandaloneOption(ctx, options, optionNames, defaultValues) {
    if (!ctx.standalone || optionNames.length === 1) {
        return;
    }
    for (const [_, opt] of options){
        if (!defaultValues[opt.name] && opt !== ctx.standalone) {
            throw new OptionNotCombinableError(ctx.standalone.name);
        }
    }
}
function validateConflictingOptions(ctx, option) {
    if (!option.conflicts?.length) {
        return;
    }
    for (const flag of option.conflicts){
        if (isset(flag, ctx.flags)) {
            throw new ConflictingOptionError(option.name, flag);
        }
    }
}
function validateDependingOptions(ctx, option, defaultValues) {
    if (!option.depends) {
        return;
    }
    for (const flag of option.depends){
        if (!isset(flag, ctx.flags) && !defaultValues[option.name]) {
            throw new DependingOptionError(option.name, flag);
        }
    }
}
function validateRequiredValues(ctx, option, name) {
    if (!option.args) {
        return;
    }
    const isArray = option.args.length > 1;
    for(let i = 0; i < option.args.length; i++){
        const arg = option.args[i];
        if (!arg.requiredValue) {
            continue;
        }
        const hasValue = isArray ? typeof ctx.flags[name][i] !== "undefined" : typeof ctx.flags[name] !== "undefined";
        if (!hasValue) {
            throw new MissingOptionValueError(option.name);
        }
    }
}
function validateRequiredOptions(ctx, options, opts) {
    if (!opts.flags?.length) {
        return;
    }
    const optionsValues = [
        ...options.values()
    ];
    for (const option of opts.flags){
        if (!option.required || paramCaseToCamelCase(option.name) in ctx.flags) {
            continue;
        }
        const conflicts = option.conflicts ?? [];
        const hasConflict = conflicts.find((flag)=>!!ctx.flags[flag]);
        const hasConflicts = hasConflict || optionsValues.find((opt)=>opt.conflicts?.find((flag)=>flag === option.name));
        if (hasConflicts) {
            continue;
        }
        throw new MissingRequiredOptionError(option.name);
    }
}
function isset(flagName, flags) {
    const name = paramCaseToCamelCase(flagName);
    return typeof flags[name] !== "undefined";
}
const integer = (type)=>{
    const value = Number(type.value);
    if (Number.isInteger(value)) {
        return value;
    }
    throw new InvalidTypeError(type);
};
const DefaultTypes = {
    string,
    number,
    integer,
    boolean: __boolean
};
function parseFlags(argsOrCtx, opts = {}) {
    let args;
    let ctx;
    if (Array.isArray(argsOrCtx)) {
        ctx = {};
        args = argsOrCtx;
    } else {
        ctx = argsOrCtx;
        args = argsOrCtx.unknown;
        argsOrCtx.unknown = [];
    }
    args = args.slice();
    ctx.flags ??= {};
    ctx.literal ??= [];
    ctx.unknown ??= [];
    ctx.stopEarly = false;
    ctx.stopOnUnknown = false;
    opts.dotted ??= true;
    validateOptions(opts);
    const options = parseArgs(ctx, args, opts);
    validateFlags(ctx, opts, options);
    if (opts.dotted) {
        parseDottedOptions(ctx);
    }
    return ctx;
}
function validateOptions(opts) {
    opts.flags?.forEach((opt)=>{
        opt.depends?.forEach((flag)=>{
            if (!opts.flags || !getOption(opts.flags, flag)) {
                throw new UnknownRequiredOptionError(flag, opts.flags ?? []);
            }
        });
        opt.conflicts?.forEach((flag)=>{
            if (!opts.flags || !getOption(opts.flags, flag)) {
                throw new UnknownConflictingOptionError(flag, opts.flags ?? []);
            }
        });
    });
}
function parseArgs(ctx, args, opts) {
    const optionsMap = new Map();
    let inLiteral = false;
    for(let argsIndex = 0; argsIndex < args.length; argsIndex++){
        let option;
        let current = args[argsIndex];
        let currentValue;
        let negate = false;
        if (inLiteral) {
            ctx.literal.push(current);
            continue;
        } else if (current === "--") {
            inLiteral = true;
            continue;
        } else if (ctx.stopEarly || ctx.stopOnUnknown) {
            ctx.unknown.push(current);
            continue;
        }
        const isFlag = current.length > 1 && current[0] === "-";
        if (!isFlag) {
            if (opts.stopEarly) {
                ctx.stopEarly = true;
            }
            ctx.unknown.push(current);
            continue;
        }
        const isShort = current[1] !== "-";
        const isLong = isShort ? false : current.length > 3 && current[2] !== "-";
        if (!isShort && !isLong) {
            throw new InvalidOptionError(current, opts.flags ?? []);
        }
        if (isShort && current.length > 2 && current[2] !== ".") {
            args.splice(argsIndex, 1, ...splitFlags(current));
            current = args[argsIndex];
        } else if (isLong && current.startsWith("--no-")) {
            negate = true;
        }
        const equalSignIndex = current.indexOf("=");
        if (equalSignIndex !== -1) {
            currentValue = current.slice(equalSignIndex + 1) || undefined;
            current = current.slice(0, equalSignIndex);
        }
        if (opts.flags) {
            option = getOption(opts.flags, current);
            if (!option) {
                const name = current.replace(/^-+/, "");
                option = matchWildCardOptions(name, opts.flags);
                if (!option) {
                    if (opts.stopOnUnknown) {
                        ctx.stopOnUnknown = true;
                        ctx.unknown.push(args[argsIndex]);
                        continue;
                    }
                    throw new UnknownOptionError(current, opts.flags);
                }
            }
        } else {
            option = {
                name: current.replace(/^-+/, ""),
                optionalValue: true,
                type: OptionType.STRING
            };
        }
        if (option.standalone) {
            ctx.standalone = option;
        }
        const positiveName = negate ? option.name.replace(/^no-?/, "") : option.name;
        const propName = paramCaseToCamelCase(positiveName);
        if (typeof ctx.flags[propName] !== "undefined") {
            if (!opts.flags?.length) {
                option.collect = true;
            } else if (!option.collect) {
                throw new DuplicateOptionError(current);
            }
        }
        if (option.type && !option.args?.length) {
            option.args = [
                {
                    type: option.type,
                    requiredValue: option.requiredValue,
                    optionalValue: option.optionalValue,
                    variadic: option.variadic,
                    list: option.list,
                    separator: option.separator
                }
            ];
        }
        if (opts.flags?.length && !option.args?.length && typeof currentValue !== "undefined") {
            throw new UnexpectedOptionValueError(option.name, currentValue);
        }
        let optionArgsIndex = 0;
        let inOptionalArg = false;
        const next = ()=>currentValue ?? args[argsIndex + 1];
        const previous = ctx.flags[propName];
        parseNext(option);
        if (typeof ctx.flags[propName] === "undefined") {
            if (option.args?.[optionArgsIndex]?.requiredValue) {
                throw new MissingOptionValueError(option.name);
            } else if (typeof option.default !== "undefined") {
                ctx.flags[propName] = getDefaultValue(option);
            } else {
                ctx.flags[propName] = true;
            }
        }
        if (option.value) {
            ctx.flags[propName] = option.value(ctx.flags[propName], previous);
        } else if (option.collect) {
            const value = typeof previous !== "undefined" ? Array.isArray(previous) ? previous : [
                previous
            ] : [];
            value.push(ctx.flags[propName]);
            ctx.flags[propName] = value;
        }
        optionsMap.set(propName, option);
        opts.option?.(option, ctx.flags[propName]);
        function parseNext(option) {
            if (negate) {
                ctx.flags[propName] = false;
                return;
            } else if (!option.args?.length) {
                ctx.flags[propName] = undefined;
                return;
            }
            const arg = option.args[optionArgsIndex];
            if (!arg) {
                const flag = next();
                throw new UnknownOptionError(flag, opts.flags ?? []);
            }
            if (!arg.type) {
                arg.type = OptionType.BOOLEAN;
            }
            if (option.args?.length && !option.type) {
                if ((typeof arg.optionalValue === "undefined" || arg.optionalValue === false) && typeof arg.requiredValue === "undefined") {
                    arg.requiredValue = true;
                }
            } else {
                if (arg.type !== OptionType.BOOLEAN && (typeof arg.optionalValue === "undefined" || arg.optionalValue === false) && typeof arg.requiredValue === "undefined") {
                    arg.requiredValue = true;
                }
            }
            if (!arg.requiredValue) {
                inOptionalArg = true;
            } else if (inOptionalArg) {
                throw new UnexpectedRequiredArgumentError(option.name);
            }
            let result;
            let increase = false;
            if (arg.list && hasNext(arg)) {
                const parsed = next().split(arg.separator || ",").map((nextValue)=>{
                    const value = parseValue(option, arg, nextValue);
                    if (typeof value === "undefined") {
                        throw new InvalidOptionValueError(option.name, arg.type ?? "?", nextValue);
                    }
                    return value;
                });
                if (parsed?.length) {
                    result = parsed;
                }
            } else {
                if (hasNext(arg)) {
                    result = parseValue(option, arg, next());
                } else if (arg.optionalValue && arg.type === OptionType.BOOLEAN) {
                    result = true;
                }
            }
            if (increase && typeof currentValue === "undefined") {
                argsIndex++;
                if (!arg.variadic) {
                    optionArgsIndex++;
                } else if (option.args[optionArgsIndex + 1]) {
                    throw new UnexpectedArgumentAfterVariadicArgumentError(next());
                }
            }
            if (typeof result !== "undefined" && (option.args.length > 1 || arg.variadic)) {
                if (!ctx.flags[propName]) {
                    ctx.flags[propName] = [];
                }
                ctx.flags[propName].push(result);
                if (hasNext(arg)) {
                    parseNext(option);
                }
            } else {
                ctx.flags[propName] = result;
            }
            function hasNext(arg) {
                if (!option.args?.length) {
                    return false;
                }
                const nextValue = currentValue ?? args[argsIndex + 1];
                if (!nextValue) {
                    return false;
                }
                if (option.args.length > 1 && optionArgsIndex >= option.args.length) {
                    return false;
                }
                if (arg.requiredValue) {
                    return true;
                }
                if (option.equalsSign && arg.optionalValue && !arg.variadic && typeof currentValue === "undefined") {
                    return false;
                }
                if (arg.optionalValue || arg.variadic) {
                    return nextValue[0] !== "-" || typeof currentValue !== "undefined" || arg.type === OptionType.NUMBER && !isNaN(Number(nextValue));
                }
                return false;
            }
            function parseValue(option, arg, value) {
                const result = opts.parse ? opts.parse({
                    label: "Option",
                    type: arg.type || OptionType.STRING,
                    name: `--${option.name}`,
                    value
                }) : parseDefaultType(option, arg, value);
                if (typeof result !== "undefined") {
                    increase = true;
                }
                return result;
            }
        }
    }
    return optionsMap;
}
function parseDottedOptions(ctx) {
    ctx.flags = Object.keys(ctx.flags).reduce((result, key)=>{
        if (~key.indexOf(".")) {
            key.split(".").reduce((result, subKey, index, parts)=>{
                if (index === parts.length - 1) {
                    result[subKey] = ctx.flags[key];
                } else {
                    result[subKey] = result[subKey] ?? {};
                }
                return result[subKey];
            }, result);
        } else {
            result[key] = ctx.flags[key];
        }
        return result;
    }, {});
}
function splitFlags(flag) {
    flag = flag.slice(1);
    const normalized = [];
    const index = flag.indexOf("=");
    const flags = (index !== -1 ? flag.slice(0, index) : flag).split("");
    if (isNaN(Number(flag[flag.length - 1]))) {
        flags.forEach((val)=>normalized.push(`-${val}`));
    } else {
        normalized.push(`-${flags.shift()}`);
        if (flags.length) {
            normalized.push(flags.join(""));
        }
    }
    if (index !== -1) {
        normalized[normalized.length - 1] += flag.slice(index);
    }
    return normalized;
}
function parseDefaultType(option, arg, value) {
    const type = arg.type || OptionType.STRING;
    const parseType = DefaultTypes[type];
    if (!parseType) {
        throw new UnknownTypeError(type, Object.keys(DefaultTypes));
    }
    return parseType({
        label: "Option",
        type,
        name: `--${option.name}`,
        value
    });
}
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function setColorEnabled(value) {
    if (noColor) {
        return;
    }
    enabled = value;
}
function getColorEnabled() {
    return enabled;
}
function code(open, close) {
    return {
        open: `\x1b[${open.join(";")}m`,
        close: `\x1b[${close}m`,
        regexp: new RegExp(`\\x1b\\[${close}m`, "g")
    };
}
function run(str, code) {
    return enabled ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}` : str;
}
function reset(str) {
    return run(str, code([
        0
    ], 0));
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function dim(str) {
    return run(str, code([
        2
    ], 22));
}
function italic(str) {
    return run(str, code([
        3
    ], 23));
}
function underline(str) {
    return run(str, code([
        4
    ], 24));
}
function inverse(str) {
    return run(str, code([
        7
    ], 27));
}
function hidden(str) {
    return run(str, code([
        8
    ], 28));
}
function strikethrough(str) {
    return run(str, code([
        9
    ], 29));
}
function black(str) {
    return run(str, code([
        30
    ], 39));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function yellow(str) {
    return run(str, code([
        33
    ], 39));
}
function blue(str) {
    return run(str, code([
        34
    ], 39));
}
function magenta(str) {
    return run(str, code([
        35
    ], 39));
}
function cyan(str) {
    return run(str, code([
        36
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function brightRed(str) {
    return run(str, code([
        91
    ], 39));
}
function brightGreen(str) {
    return run(str, code([
        92
    ], 39));
}
function brightYellow(str) {
    return run(str, code([
        93
    ], 39));
}
function brightBlue(str) {
    return run(str, code([
        94
    ], 39));
}
function brightMagenta(str) {
    return run(str, code([
        95
    ], 39));
}
function brightCyan(str) {
    return run(str, code([
        96
    ], 39));
}
function brightWhite(str) {
    return run(str, code([
        97
    ], 39));
}
function bgBlack(str) {
    return run(str, code([
        40
    ], 49));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
function bgYellow(str) {
    return run(str, code([
        43
    ], 49));
}
function bgBlue(str) {
    return run(str, code([
        44
    ], 49));
}
function bgMagenta(str) {
    return run(str, code([
        45
    ], 49));
}
function bgCyan(str) {
    return run(str, code([
        46
    ], 49));
}
function bgWhite(str) {
    return run(str, code([
        47
    ], 49));
}
function bgBrightBlack(str) {
    return run(str, code([
        100
    ], 49));
}
function bgBrightRed(str) {
    return run(str, code([
        101
    ], 49));
}
function bgBrightGreen(str) {
    return run(str, code([
        102
    ], 49));
}
function bgBrightYellow(str) {
    return run(str, code([
        103
    ], 49));
}
function bgBrightBlue(str) {
    return run(str, code([
        104
    ], 49));
}
function bgBrightMagenta(str) {
    return run(str, code([
        105
    ], 49));
}
function bgBrightCyan(str) {
    return run(str, code([
        106
    ], 49));
}
function bgBrightWhite(str) {
    return run(str, code([
        107
    ], 49));
}
function clampAndTruncate(n, max = 255, min = 0) {
    return Math.trunc(Math.max(Math.min(n, max), min));
}
function rgb8(str, color) {
    return run(str, code([
        38,
        5,
        clampAndTruncate(color)
    ], 39));
}
function bgRgb8(str, color) {
    return run(str, code([
        48,
        5,
        clampAndTruncate(color)
    ], 49));
}
function rgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([
            38,
            2,
            color >> 16 & 0xff,
            color >> 8 & 0xff,
            color & 0xff
        ], 39));
    }
    return run(str, code([
        38,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
    ], 39));
}
function bgRgb24(str, color) {
    if (typeof color === "number") {
        return run(str, code([
            48,
            2,
            color >> 16 & 0xff,
            color >> 8 & 0xff,
            color & 0xff
        ], 49));
    }
    return run(str, code([
        48,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
    ], 49));
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
].join("|"), "g");
function stripColor(string) {
    return string.replace(ANSI_PATTERN, "");
}
const mod = {
    setColorEnabled: setColorEnabled,
    getColorEnabled: getColorEnabled,
    reset: reset,
    bold: bold,
    dim: dim,
    italic: italic,
    underline: underline,
    inverse: inverse,
    hidden: hidden,
    strikethrough: strikethrough,
    black: black,
    red: red,
    green: green,
    yellow: yellow,
    blue: blue,
    magenta: magenta,
    cyan: cyan,
    white: white,
    gray: gray,
    brightBlack: brightBlack,
    brightRed: brightRed,
    brightGreen: brightGreen,
    brightYellow: brightYellow,
    brightBlue: brightBlue,
    brightMagenta: brightMagenta,
    brightCyan: brightCyan,
    brightWhite: brightWhite,
    bgBlack: bgBlack,
    bgRed: bgRed,
    bgGreen: bgGreen,
    bgYellow: bgYellow,
    bgBlue: bgBlue,
    bgMagenta: bgMagenta,
    bgCyan: bgCyan,
    bgWhite: bgWhite,
    bgBrightBlack: bgBrightBlack,
    bgBrightRed: bgBrightRed,
    bgBrightGreen: bgBrightGreen,
    bgBrightYellow: bgBrightYellow,
    bgBrightBlue: bgBrightBlue,
    bgBrightMagenta: bgBrightMagenta,
    bgBrightCyan: bgBrightCyan,
    bgBrightWhite: bgBrightWhite,
    rgb8: rgb8,
    bgRgb8: bgRgb8,
    rgb24: rgb24,
    bgRgb24: bgRgb24,
    stripColor: stripColor
};
class Type {
}
class BooleanType extends Type {
    parse(type) {
        return __boolean(type);
    }
    complete() {
        return [
            "true",
            "false"
        ];
    }
}
class StringType extends Type {
    parse(type) {
        return string(type);
    }
}
class FileType extends StringType {
    constructor(){
        super();
    }
}
class NumberType extends Type {
    parse(type) {
        return number(type);
    }
}
const border = {
    top: "─",
    topMid: "┬",
    topLeft: "┌",
    topRight: "┐",
    bottom: "─",
    bottomMid: "┴",
    bottomLeft: "└",
    bottomRight: "┘",
    left: "│",
    leftMid: "├",
    mid: "─",
    midMid: "┼",
    right: "│",
    rightMid: "┤",
    middle: "│"
};
class Cell {
    value;
    options;
    get length() {
        return this.toString().length;
    }
    static from(value) {
        const cell = new this(value);
        if (value instanceof Cell) {
            cell.options = {
                ...value.options
            };
        }
        return cell;
    }
    constructor(value){
        this.value = value;
        this.options = {};
    }
    toString() {
        return this.value.toString();
    }
    setValue(value) {
        this.value = value;
        return this;
    }
    clone(value) {
        const cell = new Cell(value ?? this);
        cell.options = {
            ...this.options
        };
        return cell;
    }
    border(enable, override = true) {
        if (override || typeof this.options.border === "undefined") {
            this.options.border = enable;
        }
        return this;
    }
    colSpan(span, override = true) {
        if (override || typeof this.options.colSpan === "undefined") {
            this.options.colSpan = span;
        }
        return this;
    }
    rowSpan(span, override = true) {
        if (override || typeof this.options.rowSpan === "undefined") {
            this.options.rowSpan = span;
        }
        return this;
    }
    align(direction, override = true) {
        if (override || typeof this.options.align === "undefined") {
            this.options.align = direction;
        }
        return this;
    }
    getBorder() {
        return this.options.border === true;
    }
    getColSpan() {
        return typeof this.options.colSpan === "number" && this.options.colSpan > 0 ? this.options.colSpan : 1;
    }
    getRowSpan() {
        return typeof this.options.rowSpan === "number" && this.options.rowSpan > 0 ? this.options.rowSpan : 1;
    }
    getAlign() {
        return this.options.align ?? "left";
    }
}
class Row extends Array {
    options = {};
    static from(cells) {
        const row = new this(...cells);
        if (cells instanceof Row) {
            row.options = {
                ...cells.options
            };
        }
        return row;
    }
    clone() {
        const row = new Row(...this.map((cell)=>cell instanceof Cell ? cell.clone() : cell));
        row.options = {
            ...this.options
        };
        return row;
    }
    border(enable, override = true) {
        if (override || typeof this.options.border === "undefined") {
            this.options.border = enable;
        }
        return this;
    }
    align(direction, override = true) {
        if (override || typeof this.options.align === "undefined") {
            this.options.align = direction;
        }
        return this;
    }
    getBorder() {
        return this.options.border === true;
    }
    hasBorder() {
        return this.getBorder() || this.some((cell)=>cell instanceof Cell && cell.getBorder());
    }
    getAlign() {
        return this.options.align ?? "left";
    }
}
function consumeWords(length, content) {
    let consumed = "";
    const words = content.split("\n")[0]?.split(/ /g);
    for(let i = 0; i < words.length; i++){
        const word = words[i];
        if (consumed) {
            const nextLength = strLength(word);
            const consumedLength = strLength(consumed);
            if (consumedLength + nextLength >= length) {
                break;
            }
        }
        consumed += (i > 0 ? " " : "") + word;
    }
    return consumed;
}
function longest(index, rows, maxWidth) {
    const cellLengths = rows.map((row)=>{
        const cell = row[index];
        const cellValue = cell instanceof Cell && cell.getColSpan() > 1 ? "" : cell?.toString() || "";
        return cellValue.split("\n").map((line)=>{
            const str = typeof maxWidth === "undefined" ? line : consumeWords(maxWidth, line);
            return strLength(str) || 0;
        });
    }).flat();
    return Math.max(...cellLengths);
}
const strLength = (str)=>{
    str = stripColor(str);
    let length = 0;
    for(let i = 0; i < str.length; i++){
        const charCode = str.charCodeAt(i);
        if (charCode >= 19968 && charCode <= 40869) {
            length += 2;
        } else {
            length += 1;
        }
    }
    return length;
};
class TableLayout {
    table;
    options;
    constructor(table, options){
        this.table = table;
        this.options = options;
    }
    toString() {
        const opts = this.createLayout();
        return opts.rows.length ? this.renderRows(opts) : "";
    }
    createLayout() {
        Object.keys(this.options.chars).forEach((key)=>{
            if (typeof this.options.chars[key] !== "string") {
                this.options.chars[key] = "";
            }
        });
        const hasBodyBorder = this.table.getBorder() || this.table.hasBodyBorder();
        const hasHeaderBorder = this.table.hasHeaderBorder();
        const hasBorder = hasHeaderBorder || hasBodyBorder;
        const rows = this.#getRows();
        const columns = Math.max(...rows.map((row)=>row.length));
        for (const row of rows){
            const length = row.length;
            if (length < columns) {
                const diff = columns - length;
                for(let i = 0; i < diff; i++){
                    row.push(this.createCell(null, row));
                }
            }
        }
        const padding = [];
        const width = [];
        for(let colIndex = 0; colIndex < columns; colIndex++){
            const minColWidth = Array.isArray(this.options.minColWidth) ? this.options.minColWidth[colIndex] : this.options.minColWidth;
            const maxColWidth = Array.isArray(this.options.maxColWidth) ? this.options.maxColWidth[colIndex] : this.options.maxColWidth;
            const colWidth = longest(colIndex, rows, maxColWidth);
            width[colIndex] = Math.min(maxColWidth, Math.max(minColWidth, colWidth));
            padding[colIndex] = Array.isArray(this.options.padding) ? this.options.padding[colIndex] : this.options.padding;
        }
        return {
            padding,
            width,
            rows,
            columns,
            hasBorder,
            hasBodyBorder,
            hasHeaderBorder
        };
    }
    #getRows() {
        const header = this.table.getHeader();
        const rows = header ? [
            header,
            ...this.table
        ] : this.table.slice();
        const hasSpan = rows.some((row)=>row.some((cell)=>cell instanceof Cell && (cell.getColSpan() > 1 || cell.getRowSpan() > 1)));
        if (hasSpan) {
            return this.spanRows(rows);
        }
        return rows.map((row)=>{
            const newRow = this.createRow(row);
            for(let i = 0; i < row.length; i++){
                newRow[i] = this.createCell(row[i], newRow);
            }
            return newRow;
        });
    }
    spanRows(rows) {
        const rowSpan = [];
        let colSpan = 1;
        let rowIndex = -1;
        while(true){
            rowIndex++;
            if (rowIndex === rows.length && rowSpan.every((span)=>span === 1)) {
                break;
            }
            const row = rows[rowIndex] = this.createRow(rows[rowIndex] || []);
            let colIndex = -1;
            while(true){
                colIndex++;
                if (colIndex === row.length && colIndex === rowSpan.length && colSpan === 1) {
                    break;
                }
                if (colSpan > 1) {
                    colSpan--;
                    rowSpan[colIndex] = rowSpan[colIndex - 1];
                    row.splice(colIndex, this.getDeleteCount(rows, rowIndex, colIndex), row[colIndex - 1]);
                    continue;
                }
                if (rowSpan[colIndex] > 1) {
                    rowSpan[colIndex]--;
                    rows[rowIndex].splice(colIndex, this.getDeleteCount(rows, rowIndex, colIndex), rows[rowIndex - 1][colIndex]);
                    continue;
                }
                const cell = row[colIndex] = this.createCell(row[colIndex] || null, row);
                colSpan = cell.getColSpan();
                rowSpan[colIndex] = cell.getRowSpan();
            }
        }
        return rows;
    }
    getDeleteCount(rows, rowIndex, colIndex) {
        return colIndex <= rows[rowIndex].length - 1 && typeof rows[rowIndex][colIndex] === "undefined" ? 1 : 0;
    }
    createRow(row) {
        return Row.from(row).border(this.table.getBorder(), false).align(this.table.getAlign(), false);
    }
    createCell(cell, row) {
        return Cell.from(cell ?? "").border(row.getBorder(), false).align(row.getAlign(), false);
    }
    renderRows(opts) {
        let result = "";
        const rowSpan = new Array(opts.columns).fill(1);
        for(let rowIndex = 0; rowIndex < opts.rows.length; rowIndex++){
            result += this.renderRow(rowSpan, rowIndex, opts);
        }
        return result.slice(0, -1);
    }
    renderRow(rowSpan, rowIndex, opts, isMultiline) {
        const row = opts.rows[rowIndex];
        const prevRow = opts.rows[rowIndex - 1];
        const nextRow = opts.rows[rowIndex + 1];
        let result = "";
        let colSpan = 1;
        if (!isMultiline && rowIndex === 0 && row.hasBorder()) {
            result += this.renderBorderRow(undefined, row, rowSpan, opts);
        }
        let isMultilineRow = false;
        result += " ".repeat(this.options.indent || 0);
        for(let colIndex = 0; colIndex < opts.columns; colIndex++){
            if (colSpan > 1) {
                colSpan--;
                rowSpan[colIndex] = rowSpan[colIndex - 1];
                continue;
            }
            result += this.renderCell(colIndex, row, opts);
            if (rowSpan[colIndex] > 1) {
                if (!isMultiline) {
                    rowSpan[colIndex]--;
                }
            } else if (!prevRow || prevRow[colIndex] !== row[colIndex]) {
                rowSpan[colIndex] = row[colIndex].getRowSpan();
            }
            colSpan = row[colIndex].getColSpan();
            if (rowSpan[colIndex] === 1 && row[colIndex].length) {
                isMultilineRow = true;
            }
        }
        if (opts.columns > 0) {
            if (row[opts.columns - 1].getBorder()) {
                result += this.options.chars.right;
            } else if (opts.hasBorder) {
                result += " ";
            }
        }
        result += "\n";
        if (isMultilineRow) {
            return result + this.renderRow(rowSpan, rowIndex, opts, isMultilineRow);
        }
        if (rowIndex === 0 && opts.hasHeaderBorder || rowIndex < opts.rows.length - 1 && opts.hasBodyBorder) {
            result += this.renderBorderRow(row, nextRow, rowSpan, opts);
        }
        if (rowIndex === opts.rows.length - 1 && row.hasBorder()) {
            result += this.renderBorderRow(row, undefined, rowSpan, opts);
        }
        return result;
    }
    renderCell(colIndex, row, opts, noBorder) {
        let result = "";
        const prevCell = row[colIndex - 1];
        const cell = row[colIndex];
        if (!noBorder) {
            if (colIndex === 0) {
                if (cell.getBorder()) {
                    result += this.options.chars.left;
                } else if (opts.hasBorder) {
                    result += " ";
                }
            } else {
                if (cell.getBorder() || prevCell?.getBorder()) {
                    result += this.options.chars.middle;
                } else if (opts.hasBorder) {
                    result += " ";
                }
            }
        }
        let maxLength = opts.width[colIndex];
        const colSpan = cell.getColSpan();
        if (colSpan > 1) {
            for(let o = 1; o < colSpan; o++){
                maxLength += opts.width[colIndex + o] + opts.padding[colIndex + o];
                if (opts.hasBorder) {
                    maxLength += opts.padding[colIndex + o] + 1;
                }
            }
        }
        const { current , next  } = this.renderCellValue(cell, maxLength);
        row[colIndex].setValue(next);
        if (opts.hasBorder) {
            result += " ".repeat(opts.padding[colIndex]);
        }
        result += current;
        if (opts.hasBorder || colIndex < opts.columns - 1) {
            result += " ".repeat(opts.padding[colIndex]);
        }
        return result;
    }
    renderCellValue(cell, maxLength) {
        const length = Math.min(maxLength, strLength(cell.toString()));
        let words = consumeWords(length, cell.toString());
        const breakWord = strLength(words) > length;
        if (breakWord) {
            words = words.slice(0, length);
        }
        const next = cell.toString().slice(words.length + (breakWord ? 0 : 1));
        const fillLength = maxLength - strLength(words);
        const align = cell.getAlign();
        let current;
        if (fillLength === 0) {
            current = words;
        } else if (align === "left") {
            current = words + " ".repeat(fillLength);
        } else if (align === "center") {
            current = " ".repeat(Math.floor(fillLength / 2)) + words + " ".repeat(Math.ceil(fillLength / 2));
        } else if (align === "right") {
            current = " ".repeat(fillLength) + words;
        } else {
            throw new Error("Unknown direction: " + align);
        }
        return {
            current,
            next: cell.clone(next)
        };
    }
    renderBorderRow(prevRow, nextRow, rowSpan, opts) {
        let result = "";
        let colSpan = 1;
        for(let colIndex = 0; colIndex < opts.columns; colIndex++){
            if (rowSpan[colIndex] > 1) {
                if (!nextRow) {
                    throw new Error("invalid layout");
                }
                if (colSpan > 1) {
                    colSpan--;
                    continue;
                }
            }
            result += this.renderBorderCell(colIndex, prevRow, nextRow, rowSpan, opts);
            colSpan = nextRow?.[colIndex].getColSpan() ?? 1;
        }
        return result.length ? " ".repeat(this.options.indent) + result + "\n" : "";
    }
    renderBorderCell(colIndex, prevRow, nextRow, rowSpan, opts) {
        const a1 = prevRow?.[colIndex - 1];
        const a2 = nextRow?.[colIndex - 1];
        const b1 = prevRow?.[colIndex];
        const b2 = nextRow?.[colIndex];
        const a1Border = !!a1?.getBorder();
        const a2Border = !!a2?.getBorder();
        const b1Border = !!b1?.getBorder();
        const b2Border = !!b2?.getBorder();
        const hasColSpan = (cell)=>(cell?.getColSpan() ?? 1) > 1;
        const hasRowSpan = (cell)=>(cell?.getRowSpan() ?? 1) > 1;
        let result = "";
        if (colIndex === 0) {
            if (rowSpan[colIndex] > 1) {
                if (b1Border) {
                    result += this.options.chars.left;
                } else {
                    result += " ";
                }
            } else if (b1Border && b2Border) {
                result += this.options.chars.leftMid;
            } else if (b1Border) {
                result += this.options.chars.bottomLeft;
            } else if (b2Border) {
                result += this.options.chars.topLeft;
            } else {
                result += " ";
            }
        } else if (colIndex < opts.columns) {
            if (a1Border && b2Border || b1Border && a2Border) {
                const a1ColSpan = hasColSpan(a1);
                const a2ColSpan = hasColSpan(a2);
                const b1ColSpan = hasColSpan(b1);
                const b2ColSpan = hasColSpan(b2);
                const a1RowSpan = hasRowSpan(a1);
                const a2RowSpan = hasRowSpan(a2);
                const b1RowSpan = hasRowSpan(b1);
                const b2RowSpan = hasRowSpan(b2);
                const hasAllBorder = a1Border && b2Border && b1Border && a2Border;
                const hasAllRowSpan = a1RowSpan && b1RowSpan && a2RowSpan && b2RowSpan;
                const hasAllColSpan = a1ColSpan && b1ColSpan && a2ColSpan && b2ColSpan;
                if (hasAllRowSpan && hasAllBorder) {
                    result += this.options.chars.middle;
                } else if (hasAllColSpan && hasAllBorder && a1 === b1 && a2 === b2) {
                    result += this.options.chars.mid;
                } else if (a1ColSpan && b1ColSpan && a1 === b1) {
                    result += this.options.chars.topMid;
                } else if (a2ColSpan && b2ColSpan && a2 === b2) {
                    result += this.options.chars.bottomMid;
                } else if (a1RowSpan && a2RowSpan && a1 === a2) {
                    result += this.options.chars.leftMid;
                } else if (b1RowSpan && b2RowSpan && b1 === b2) {
                    result += this.options.chars.rightMid;
                } else {
                    result += this.options.chars.midMid;
                }
            } else if (a1Border && b1Border) {
                if (hasColSpan(a1) && hasColSpan(b1) && a1 === b1) {
                    result += this.options.chars.bottom;
                } else {
                    result += this.options.chars.bottomMid;
                }
            } else if (b1Border && b2Border) {
                if (rowSpan[colIndex] > 1) {
                    result += this.options.chars.left;
                } else {
                    result += this.options.chars.leftMid;
                }
            } else if (b2Border && a2Border) {
                if (hasColSpan(a2) && hasColSpan(b2) && a2 === b2) {
                    result += this.options.chars.top;
                } else {
                    result += this.options.chars.topMid;
                }
            } else if (a1Border && a2Border) {
                if (hasRowSpan(a1) && a1 === a2) {
                    result += this.options.chars.right;
                } else {
                    result += this.options.chars.rightMid;
                }
            } else if (a1Border) {
                result += this.options.chars.bottomRight;
            } else if (b1Border) {
                result += this.options.chars.bottomLeft;
            } else if (a2Border) {
                result += this.options.chars.topRight;
            } else if (b2Border) {
                result += this.options.chars.topLeft;
            } else {
                result += " ";
            }
        }
        const length = opts.padding[colIndex] + opts.width[colIndex] + opts.padding[colIndex];
        if (rowSpan[colIndex] > 1 && nextRow) {
            result += this.renderCell(colIndex, nextRow, opts, true);
            if (nextRow[colIndex] === nextRow[nextRow.length - 1]) {
                if (b1Border) {
                    result += this.options.chars.right;
                } else {
                    result += " ";
                }
                return result;
            }
        } else if (b1Border && b2Border) {
            result += this.options.chars.mid.repeat(length);
        } else if (b1Border) {
            result += this.options.chars.bottom.repeat(length);
        } else if (b2Border) {
            result += this.options.chars.top.repeat(length);
        } else {
            result += " ".repeat(length);
        }
        if (colIndex === opts.columns - 1) {
            if (b1Border && b2Border) {
                result += this.options.chars.rightMid;
            } else if (b1Border) {
                result += this.options.chars.bottomRight;
            } else if (b2Border) {
                result += this.options.chars.topRight;
            } else {
                result += " ";
            }
        }
        return result;
    }
}
class Table extends Array {
    static _chars = {
        ...border
    };
    options = {
        indent: 0,
        border: false,
        maxColWidth: Infinity,
        minColWidth: 0,
        padding: 1,
        chars: {
            ...Table._chars
        }
    };
    headerRow;
    static from(rows) {
        const table = new this(...rows);
        if (rows instanceof Table) {
            table.options = {
                ...rows.options
            };
            table.headerRow = rows.headerRow ? Row.from(rows.headerRow) : undefined;
        }
        return table;
    }
    static fromJson(rows) {
        return new this().fromJson(rows);
    }
    static chars(chars) {
        Object.assign(this._chars, chars);
        return this;
    }
    static render(rows) {
        Table.from(rows).render();
    }
    fromJson(rows) {
        this.header(Object.keys(rows[0]));
        this.body(rows.map((row)=>Object.values(row)));
        return this;
    }
    header(header) {
        this.headerRow = header instanceof Row ? header : Row.from(header);
        return this;
    }
    body(rows) {
        this.length = 0;
        this.push(...rows);
        return this;
    }
    clone() {
        const table = new Table(...this.map((row)=>row instanceof Row ? row.clone() : Row.from(row).clone()));
        table.options = {
            ...this.options
        };
        table.headerRow = this.headerRow?.clone();
        return table;
    }
    toString() {
        return new TableLayout(this, this.options).toString();
    }
    render() {
        console.log(this.toString());
        return this;
    }
    maxColWidth(width, override = true) {
        if (override || typeof this.options.maxColWidth === "undefined") {
            this.options.maxColWidth = width;
        }
        return this;
    }
    minColWidth(width, override = true) {
        if (override || typeof this.options.minColWidth === "undefined") {
            this.options.minColWidth = width;
        }
        return this;
    }
    indent(width, override = true) {
        if (override || typeof this.options.indent === "undefined") {
            this.options.indent = width;
        }
        return this;
    }
    padding(padding, override = true) {
        if (override || typeof this.options.padding === "undefined") {
            this.options.padding = padding;
        }
        return this;
    }
    border(enable, override = true) {
        if (override || typeof this.options.border === "undefined") {
            this.options.border = enable;
        }
        return this;
    }
    align(direction, override = true) {
        if (override || typeof this.options.align === "undefined") {
            this.options.align = direction;
        }
        return this;
    }
    chars(chars) {
        Object.assign(this.options.chars, chars);
        return this;
    }
    getHeader() {
        return this.headerRow;
    }
    getBody() {
        return [
            ...this
        ];
    }
    getMaxColWidth() {
        return this.options.maxColWidth;
    }
    getMinColWidth() {
        return this.options.minColWidth;
    }
    getIndent() {
        return this.options.indent;
    }
    getPadding() {
        return this.options.padding;
    }
    getBorder() {
        return this.options.border === true;
    }
    hasHeaderBorder() {
        const hasBorder = this.headerRow?.hasBorder();
        return hasBorder === true || this.getBorder() && hasBorder !== false;
    }
    hasBodyBorder() {
        return this.getBorder() || this.some((row)=>row instanceof Row ? row.hasBorder() : row.some((cell)=>cell instanceof Cell ? cell.getBorder : false));
    }
    hasBorder() {
        return this.hasHeaderBorder() || this.hasBodyBorder();
    }
    getAlign() {
        return this.options.align ?? "left";
    }
}
class HelpGenerator {
    cmd;
    indent;
    options;
    static generate(cmd, options) {
        return new HelpGenerator(cmd, options).generate();
    }
    constructor(cmd, options = {}){
        this.cmd = cmd;
        this.indent = 2;
        this.options = {
            types: false,
            hints: true,
            colors: true,
            long: false,
            ...options
        };
    }
    generate() {
        const areColorsEnabled = getColorEnabled();
        setColorEnabled(this.options.colors);
        const result = this.generateHeader() + this.generateMeta() + this.generateDescription() + this.generateOptions() + this.generateCommands() + this.generateEnvironmentVariables() + this.generateExamples();
        setColorEnabled(areColorsEnabled);
        return result;
    }
    generateHeader() {
        const usage = this.cmd.getUsage();
        const rows = [
            [
                bold("Usage:"),
                brightMagenta(this.cmd.getPath() + (usage ? " " + highlightArguments(usage, this.options.types) : ""))
            ]
        ];
        const version = this.cmd.getVersion();
        if (version) {
            rows.push([
                bold("Version:"),
                yellow(`${this.cmd.getVersion()}`)
            ]);
        }
        return "\n" + Table.from(rows).indent(this.indent).padding(1).toString() + "\n";
    }
    generateMeta() {
        const meta = Object.entries(this.cmd.getMeta());
        if (!meta.length) {
            return "";
        }
        const rows = [];
        for (const [name, value] of meta){
            rows.push([
                bold(`${name}: `) + value
            ]);
        }
        return "\n" + Table.from(rows).indent(this.indent).padding(1).toString() + "\n";
    }
    generateDescription() {
        if (!this.cmd.getDescription()) {
            return "";
        }
        return this.label("Description") + Table.from([
            [
                dedent(this.cmd.getDescription())
            ]
        ]).indent(this.indent * 2).maxColWidth(140).padding(1).toString() + "\n";
    }
    generateOptions() {
        const options = this.cmd.getOptions(false);
        if (!options.length) {
            return "";
        }
        let groups = [];
        const hasGroups = options.some((option)=>option.groupName);
        if (hasGroups) {
            for (const option of options){
                let group = groups.find((group)=>group.name === option.groupName);
                if (!group) {
                    group = {
                        name: option.groupName,
                        options: []
                    };
                    groups.push(group);
                }
                group.options.push(option);
            }
        } else {
            groups = [
                {
                    name: "Options",
                    options
                }
            ];
        }
        let result = "";
        for (const group of groups){
            result += this.generateOptionGroup(group);
        }
        return result;
    }
    generateOptionGroup(group) {
        if (!group.options.length) {
            return "";
        }
        const hasTypeDefinitions = !!group.options.find((option)=>!!option.typeDefinition);
        if (hasTypeDefinitions) {
            return this.label(group.name ?? "Options") + Table.from([
                ...group.options.map((option)=>[
                        option.flags.map((flag)=>brightBlue(flag)).join(", "),
                        highlightArguments(option.typeDefinition || "", this.options.types),
                        red(bold("-")),
                        getDescription(option.description, !this.options.long),
                        this.generateHints(option)
                    ])
            ]).padding([
                2,
                2,
                1,
                2
            ]).indent(this.indent * 2).maxColWidth([
                60,
                60,
                1,
                80,
                60
            ]).toString() + "\n";
        }
        return this.label(group.name ?? "Options") + Table.from([
            ...group.options.map((option)=>[
                    option.flags.map((flag)=>brightBlue(flag)).join(", "),
                    red(bold("-")),
                    getDescription(option.description, !this.options.long),
                    this.generateHints(option)
                ])
        ]).indent(this.indent * 2).maxColWidth([
            60,
            1,
            80,
            60
        ]).padding([
            2,
            1,
            2
        ]).toString() + "\n";
    }
    generateCommands() {
        const commands = this.cmd.getCommands(false);
        if (!commands.length) {
            return "";
        }
        const hasTypeDefinitions = !!commands.find((command)=>!!command.getArgsDefinition());
        if (hasTypeDefinitions) {
            return this.label("Commands") + Table.from([
                ...commands.map((command)=>[
                        [
                            command.getName(),
                            ...command.getAliases()
                        ].map((name)=>brightBlue(name)).join(", "),
                        highlightArguments(command.getArgsDefinition() || "", this.options.types),
                        red(bold("-")),
                        command.getShortDescription()
                    ])
            ]).indent(this.indent * 2).maxColWidth([
                60,
                60,
                1,
                80
            ]).padding([
                2,
                2,
                1,
                2
            ]).toString() + "\n";
        }
        return this.label("Commands") + Table.from([
            ...commands.map((command)=>[
                    [
                        command.getName(),
                        ...command.getAliases()
                    ].map((name)=>brightBlue(name)).join(", "),
                    red(bold("-")),
                    command.getShortDescription()
                ])
        ]).maxColWidth([
            60,
            1,
            80
        ]).padding([
            2,
            1,
            2
        ]).indent(this.indent * 2).toString() + "\n";
    }
    generateEnvironmentVariables() {
        const envVars = this.cmd.getEnvVars(false);
        if (!envVars.length) {
            return "";
        }
        return this.label("Environment variables") + Table.from([
            ...envVars.map((envVar)=>[
                    envVar.names.map((name)=>brightBlue(name)).join(", "),
                    highlightArgumentDetails(envVar.details, this.options.types),
                    red(bold("-")),
                    this.options.long ? dedent(envVar.description) : envVar.description.trim().split("\n", 1)[0],
                    envVar.required ? `(${yellow(`required`)})` : ""
                ])
        ]).padding([
            2,
            2,
            1,
            2
        ]).indent(this.indent * 2).maxColWidth([
            60,
            60,
            1,
            80,
            10
        ]).toString() + "\n";
    }
    generateExamples() {
        const examples = this.cmd.getExamples();
        if (!examples.length) {
            return "";
        }
        return this.label("Examples") + Table.from(examples.map((example)=>[
                dim(bold(`${capitalize(example.name)}:`)),
                dedent(example.description)
            ])).padding(1).indent(this.indent * 2).maxColWidth(150).toString() + "\n";
    }
    generateHints(option) {
        if (!this.options.hints) {
            return "";
        }
        const hints = [];
        option.required && hints.push(yellow(`required`));
        typeof option.default !== "undefined" && hints.push(bold(`Default: `) + inspect(option.default, this.options.colors));
        option.depends?.length && hints.push(yellow(bold(`Depends: `)) + italic(option.depends.map(getFlag).join(", ")));
        option.conflicts?.length && hints.push(red(bold(`Conflicts: `)) + italic(option.conflicts.map(getFlag).join(", ")));
        const type = this.cmd.getType(option.args[0]?.type)?.handler;
        if (type instanceof Type) {
            const possibleValues = type.values?.(this.cmd, this.cmd.getParent());
            if (possibleValues?.length) {
                hints.push(bold(`Values: `) + possibleValues.map((value)=>inspect(value, this.options.colors)).join(", "));
            }
        }
        if (hints.length) {
            return `(${hints.join(", ")})`;
        }
        return "";
    }
    label(label) {
        return "\n" + " ".repeat(this.indent) + bold(`${label}:`) + "\n\n";
    }
}
function capitalize(string) {
    return (string?.charAt(0).toUpperCase() + string.slice(1)) ?? "";
}
function inspect(value, colors) {
    return Deno.inspect(value, {
        depth: 1,
        colors,
        trailingComma: false
    });
}
function highlightArguments(argsDefinition, types = true) {
    if (!argsDefinition) {
        return "";
    }
    return parseArgumentsDefinition(argsDefinition, false, true).map((arg)=>typeof arg === "string" ? arg : highlightArgumentDetails(arg, types)).join(" ");
}
function highlightArgumentDetails(arg, types = true) {
    let str = "";
    str += yellow(arg.optionalValue ? "[" : "<");
    let name = "";
    name += arg.name;
    if (arg.variadic) {
        name += "...";
    }
    name = brightMagenta(name);
    str += name;
    if (types) {
        str += yellow(":");
        str += red(arg.type);
        if (arg.list) {
            str += green("[]");
        }
    }
    str += yellow(arg.optionalValue ? "]" : ">");
    return str;
}
class IntegerType extends Type {
    parse(type) {
        return integer(type);
    }
}
class Command {
    types = new Map();
    rawArgs = [];
    literalArgs = [];
    _name = "COMMAND";
    _parent;
    _globalParent;
    ver;
    desc = "";
    _usage;
    fn;
    options = [];
    commands = new Map();
    examples = [];
    envVars = [];
    aliases = [];
    completions = new Map();
    cmd = this;
    argsDefinition;
    isExecutable = false;
    throwOnError = false;
    _allowEmpty = false;
    _stopEarly = false;
    defaultCommand;
    _useRawArgs = false;
    args = [];
    isHidden = false;
    isGlobal = false;
    hasDefaults = false;
    _versionOptions;
    _helpOptions;
    _versionOption;
    _helpOption;
    _help;
    _shouldExit;
    _meta = {};
    _groupName;
    _noGlobals = false;
    errorHandler;
    versionOption(flags, desc, opts) {
        this._versionOptions = flags === false ? flags : {
            flags,
            desc,
            opts: typeof opts === "function" ? {
                action: opts
            } : opts
        };
        return this;
    }
    helpOption(flags, desc, opts) {
        this._helpOptions = flags === false ? flags : {
            flags,
            desc,
            opts: typeof opts === "function" ? {
                action: opts
            } : opts
        };
        return this;
    }
    command(nameAndArguments, cmdOrDescription, override) {
        this.reset();
        const result = splitArguments(nameAndArguments);
        const name = result.flags.shift();
        const aliases = result.flags;
        if (!name) {
            throw new MissingCommandNameError();
        }
        if (this.getBaseCommand(name, true)) {
            if (!override) {
                throw new DuplicateCommandNameError(name);
            }
            this.removeCommand(name);
        }
        let description;
        let cmd;
        if (typeof cmdOrDescription === "string") {
            description = cmdOrDescription;
        }
        if (cmdOrDescription instanceof Command) {
            cmd = cmdOrDescription.reset();
        } else {
            cmd = new Command();
        }
        cmd._name = name;
        cmd._parent = this;
        if (description) {
            cmd.description(description);
        }
        if (result.typeDefinition) {
            cmd.arguments(result.typeDefinition);
        }
        aliases.forEach((alias)=>cmd.alias(alias));
        this.commands.set(name, cmd);
        this.select(name);
        return this;
    }
    alias(alias) {
        if (this.cmd._name === alias || this.cmd.aliases.includes(alias)) {
            throw new DuplicateCommandAliasError(alias);
        }
        this.cmd.aliases.push(alias);
        return this;
    }
    reset() {
        this._groupName = undefined;
        this.cmd = this;
        return this;
    }
    select(name) {
        const cmd = this.getBaseCommand(name, true);
        if (!cmd) {
            throw new CommandNotFoundError(name, this.getBaseCommands(true));
        }
        this.cmd = cmd;
        return this;
    }
    name(name) {
        this.cmd._name = name;
        return this;
    }
    version(version) {
        if (typeof version === "string") {
            this.cmd.ver = ()=>version;
        } else if (typeof version === "function") {
            this.cmd.ver = version;
        }
        return this;
    }
    meta(name, value) {
        this.cmd._meta[name] = value;
        return this;
    }
    getMeta(name) {
        return typeof name === "undefined" ? this._meta : this._meta[name];
    }
    help(help) {
        if (typeof help === "string") {
            this.cmd._help = ()=>help;
        } else if (typeof help === "function") {
            this.cmd._help = help;
        } else {
            this.cmd._help = (cmd, options)=>HelpGenerator.generate(cmd, {
                    ...help,
                    ...options
                });
        }
        return this;
    }
    description(description) {
        this.cmd.desc = description;
        return this;
    }
    usage(usage) {
        this.cmd._usage = usage;
        return this;
    }
    hidden() {
        this.cmd.isHidden = true;
        return this;
    }
    global() {
        this.cmd.isGlobal = true;
        return this;
    }
    executable() {
        this.cmd.isExecutable = true;
        return this;
    }
    arguments(args) {
        this.cmd.argsDefinition = args;
        return this;
    }
    action(fn) {
        this.cmd.fn = fn;
        return this;
    }
    allowEmpty(allowEmpty) {
        this.cmd._allowEmpty = allowEmpty !== false;
        return this;
    }
    stopEarly(stopEarly = true) {
        this.cmd._stopEarly = stopEarly;
        return this;
    }
    useRawArgs(useRawArgs = true) {
        this.cmd._useRawArgs = useRawArgs;
        return this;
    }
    default(name) {
        this.cmd.defaultCommand = name;
        return this;
    }
    globalType(name, handler, options) {
        return this.type(name, handler, {
            ...options,
            global: true
        });
    }
    type(name, handler, options) {
        if (this.cmd.types.get(name) && !options?.override) {
            throw new DuplicateTypeError(name);
        }
        this.cmd.types.set(name, {
            ...options,
            name,
            handler: handler
        });
        if (handler instanceof Type && (typeof handler.complete !== "undefined" || typeof handler.values !== "undefined")) {
            const completeHandler = (cmd, parent)=>handler.complete?.(cmd, parent) || [];
            this.complete(name, completeHandler, options);
        }
        return this;
    }
    globalComplete(name, complete, options) {
        return this.complete(name, complete, {
            ...options,
            global: true
        });
    }
    complete(name, complete, options) {
        if (this.cmd.completions.has(name) && !options?.override) {
            throw new DuplicateCompletionError(name);
        }
        this.cmd.completions.set(name, {
            name,
            complete,
            ...options
        });
        return this;
    }
    throwErrors() {
        this.cmd.throwOnError = true;
        return this;
    }
    error(handler) {
        this.cmd.errorHandler = handler;
        return this;
    }
    getErrorHandler() {
        return this.errorHandler ?? this._parent?.errorHandler;
    }
    noExit() {
        this.cmd._shouldExit = false;
        this.throwErrors();
        return this;
    }
    noGlobals() {
        this.cmd._noGlobals = true;
        return this;
    }
    shouldThrowErrors() {
        return this.throwOnError || !!this._parent?.shouldThrowErrors();
    }
    shouldExit() {
        return this._shouldExit ?? this._parent?.shouldExit() ?? true;
    }
    globalOption(flags, desc, opts) {
        if (typeof opts === "function") {
            return this.option(flags, desc, {
                value: opts,
                global: true
            });
        }
        return this.option(flags, desc, {
            ...opts,
            global: true
        });
    }
    group(name) {
        this.cmd._groupName = name;
        return this;
    }
    option(flags, desc, opts) {
        if (typeof opts === "function") {
            return this.option(flags, desc, {
                value: opts
            });
        }
        const result = splitArguments(flags);
        const args = result.typeDefinition ? parseArgumentsDefinition(result.typeDefinition) : [];
        const option = {
            ...opts,
            name: "",
            description: desc,
            args,
            flags: result.flags,
            equalsSign: result.equalsSign,
            typeDefinition: result.typeDefinition,
            groupName: this._groupName
        };
        if (option.separator) {
            for (const arg of args){
                if (arg.list) {
                    arg.separator = option.separator;
                }
            }
        }
        for (const part of option.flags){
            const arg = part.trim();
            const isLong = /^--/.test(arg);
            const name = isLong ? arg.slice(2) : arg.slice(1);
            if (this.cmd.getBaseOption(name, true)) {
                if (opts?.override) {
                    this.removeOption(name);
                } else {
                    throw new DuplicateOptionNameError(name);
                }
            }
            if (!option.name && isLong) {
                option.name = name;
            } else if (!option.aliases) {
                option.aliases = [
                    name
                ];
            } else {
                option.aliases.push(name);
            }
        }
        if (option.prepend) {
            this.cmd.options.unshift(option);
        } else {
            this.cmd.options.push(option);
        }
        return this;
    }
    example(name, description) {
        if (this.cmd.hasExample(name)) {
            throw new DuplicateExampleError(name);
        }
        this.cmd.examples.push({
            name,
            description
        });
        return this;
    }
    globalEnv(name, description, options) {
        return this.env(name, description, {
            ...options,
            global: true
        });
    }
    env(name, description, options) {
        const result = splitArguments(name);
        if (!result.typeDefinition) {
            result.typeDefinition = "<value:boolean>";
        }
        if (result.flags.some((envName)=>this.cmd.getBaseEnvVar(envName, true))) {
            throw new DuplicateEnvVarError(name);
        }
        const details = parseArgumentsDefinition(result.typeDefinition);
        if (details.length > 1) {
            throw new TooManyEnvVarValuesError(name);
        } else if (details.length && details[0].optionalValue) {
            throw new UnexpectedOptionalEnvVarValueError(name);
        } else if (details.length && details[0].variadic) {
            throw new UnexpectedVariadicEnvVarValueError(name);
        }
        this.cmd.envVars.push({
            name: result.flags[0],
            names: result.flags,
            description,
            type: details[0].type,
            details: details.shift(),
            ...options
        });
        return this;
    }
    parse(args = Deno.args) {
        const ctx = {
            unknown: args.slice(),
            flags: {},
            env: {},
            literal: [],
            stopEarly: false,
            stopOnUnknown: false
        };
        return this.parseCommand(ctx);
    }
    async parseCommand(ctx) {
        try {
            this.reset();
            this.registerDefaults();
            this.rawArgs = ctx.unknown.slice();
            if (this.isExecutable) {
                await this.executeExecutable(ctx.unknown);
                return {
                    options: {},
                    args: [],
                    cmd: this,
                    literal: []
                };
            } else if (this._useRawArgs) {
                await this.parseEnvVars(ctx, this.envVars);
                return this.execute(ctx.env, ...ctx.unknown);
            }
            let preParseGlobals = false;
            let subCommand;
            if (ctx.unknown.length > 0) {
                subCommand = this.getSubCommand(ctx);
                if (!subCommand) {
                    const optionName = ctx.unknown[0].replace(/^-+/, "");
                    const option = this.getOption(optionName, true);
                    if (option?.global) {
                        preParseGlobals = true;
                        await this.parseGlobalOptionsAndEnvVars(ctx);
                    }
                }
            }
            if (subCommand || ctx.unknown.length > 0) {
                subCommand ??= this.getSubCommand(ctx);
                if (subCommand) {
                    subCommand._globalParent = this;
                    return subCommand.parseCommand(ctx);
                }
            }
            await this.parseOptionsAndEnvVars(ctx, preParseGlobals);
            const options = {
                ...ctx.env,
                ...ctx.flags
            };
            const args = this.parseArguments(ctx, options);
            this.literalArgs = ctx.literal;
            if (ctx.action) {
                await ctx.action.action.call(this, options, ...args);
                if (ctx.action.standalone) {
                    return {
                        options,
                        args,
                        cmd: this,
                        literal: this.literalArgs
                    };
                }
            }
            return await this.execute(options, ...args);
        } catch (error) {
            this.handleError(error);
        }
    }
    getSubCommand(ctx) {
        const subCommand = this.getCommand(ctx.unknown[0], true);
        if (subCommand) {
            ctx.unknown.shift();
        }
        return subCommand;
    }
    async parseGlobalOptionsAndEnvVars(ctx) {
        const isHelpOption = this.getHelpOption()?.flags.includes(ctx.unknown[0]);
        const envVars = [
            ...this.envVars.filter((envVar)=>envVar.global),
            ...this.getGlobalEnvVars(true)
        ];
        await this.parseEnvVars(ctx, envVars, !isHelpOption);
        const options = [
            ...this.options.filter((option)=>option.global),
            ...this.getGlobalOptions(true)
        ];
        this.parseOptions(ctx, options, {
            stopEarly: true,
            stopOnUnknown: true,
            dotted: false
        });
    }
    async parseOptionsAndEnvVars(ctx, preParseGlobals) {
        const helpOption = this.getHelpOption();
        const isVersionOption = this._versionOption?.flags.includes(ctx.unknown[0]);
        const isHelpOption = helpOption && ctx.flags?.[helpOption.name] === true;
        const envVars = preParseGlobals ? this.envVars.filter((envVar)=>!envVar.global) : this.getEnvVars(true);
        await this.parseEnvVars(ctx, envVars, !isHelpOption && !isVersionOption);
        const options = this.getOptions(true);
        this.parseOptions(ctx, options);
    }
    registerDefaults() {
        if (this.hasDefaults || this.getParent()) {
            return this;
        }
        this.hasDefaults = true;
        this.reset();
        !this.types.has("string") && this.type("string", new StringType(), {
            global: true
        });
        !this.types.has("number") && this.type("number", new NumberType(), {
            global: true
        });
        !this.types.has("integer") && this.type("integer", new IntegerType(), {
            global: true
        });
        !this.types.has("boolean") && this.type("boolean", new BooleanType(), {
            global: true
        });
        !this.types.has("file") && this.type("file", new FileType(), {
            global: true
        });
        if (!this._help) {
            this.help({
                hints: true,
                types: false
            });
        }
        if (this._versionOptions !== false && (this._versionOptions || this.ver)) {
            this.option(this._versionOptions?.flags || "-V, --version", this._versionOptions?.desc || "Show the version number for this program.", {
                standalone: true,
                prepend: true,
                action: async function() {
                    const __long = this.getRawArgs().includes(`--${this._versionOption?.name}`);
                    if (__long) {
                        await this.checkVersion();
                        this.showLongVersion();
                    } else {
                        this.showVersion();
                    }
                    this.exit();
                },
                ...this._versionOptions?.opts ?? {}
            });
            this._versionOption = this.options[0];
        }
        if (this._helpOptions !== false) {
            this.option(this._helpOptions?.flags || "-h, --help", this._helpOptions?.desc || "Show this help.", {
                standalone: true,
                global: true,
                prepend: true,
                action: async function() {
                    const __long = this.getRawArgs().includes(`--${this.getHelpOption()?.name}`);
                    await this.checkVersion();
                    this.showHelp({
                        long: __long
                    });
                    this.exit();
                },
                ...this._helpOptions?.opts ?? {}
            });
            this._helpOption = this.options[0];
        }
        return this;
    }
    async execute(options, ...args) {
        if (this.fn) {
            await this.fn(options, ...args);
        } else if (this.defaultCommand) {
            const cmd = this.getCommand(this.defaultCommand, true);
            if (!cmd) {
                throw new DefaultCommandNotFoundError(this.defaultCommand, this.getCommands());
            }
            cmd._globalParent = this;
            return cmd.execute(options, ...args);
        }
        return {
            options,
            args,
            cmd: this,
            literal: this.literalArgs
        };
    }
    async executeExecutable(args) {
        const command = this.getPath().replace(/\s+/g, "-");
        await Deno.permissions.request({
            name: "run",
            command
        });
        try {
            const process = Deno.run({
                cmd: [
                    command,
                    ...args
                ]
            });
            const status = await process.status();
            if (!status.success) {
                Deno.exit(status.code);
            }
        } catch (error) {
            if (error instanceof Deno.errors.NotFound) {
                throw new CommandExecutableNotFoundError(command);
            }
            throw error;
        }
    }
    parseOptions(ctx, options, { stopEarly =this._stopEarly , stopOnUnknown =false , dotted =true  } = {}) {
        parseFlags(ctx, {
            stopEarly,
            stopOnUnknown,
            dotted,
            allowEmpty: this._allowEmpty,
            flags: options,
            ignoreDefaults: ctx.env,
            parse: (type)=>this.parseType(type),
            option: (option)=>{
                if (!ctx.action && option.action) {
                    ctx.action = option;
                }
            }
        });
    }
    parseType(type) {
        const typeSettings = this.getType(type.type);
        if (!typeSettings) {
            throw new UnknownTypeError(type.type, this.getTypes().map((type)=>type.name));
        }
        return typeSettings.handler instanceof Type ? typeSettings.handler.parse(type) : typeSettings.handler(type);
    }
    async parseEnvVars(ctx, envVars, validate = true) {
        for (const envVar of envVars){
            const env = await this.findEnvVar(envVar.names);
            if (env) {
                const parseType = (value)=>{
                    return this.parseType({
                        label: "Environment variable",
                        type: envVar.type,
                        name: env.name,
                        value
                    });
                };
                const propertyName = underscoreToCamelCase(envVar.prefix ? envVar.names[0].replace(new RegExp(`^${envVar.prefix}`), "") : envVar.names[0]);
                if (envVar.details.list) {
                    ctx.env[propertyName] = env.value.split(envVar.details.separator ?? ",").map(parseType);
                } else {
                    ctx.env[propertyName] = parseType(env.value);
                }
                if (envVar.value && typeof ctx.env[propertyName] !== "undefined") {
                    ctx.env[propertyName] = envVar.value(ctx.env[propertyName]);
                }
            } else if (envVar.required && validate) {
                throw new MissingRequiredEnvVarError(envVar);
            }
        }
    }
    async findEnvVar(names) {
        for (const name of names){
            const status = await Deno.permissions.query({
                name: "env",
                variable: name
            });
            if (status.state === "granted") {
                const value = Deno.env.get(name);
                if (value) {
                    return {
                        name,
                        value
                    };
                }
            }
        }
        return undefined;
    }
    parseArguments(ctx, options) {
        const params = [];
        const args = ctx.unknown.slice();
        if (!this.hasArguments()) {
            if (args.length) {
                if (this.hasCommands(true)) {
                    if (this.hasCommand(args[0], true)) {
                        throw new TooManyArgumentsError(args);
                    } else {
                        throw new UnknownCommandError(args[0], this.getCommands());
                    }
                } else {
                    throw new NoArgumentsAllowedError(this.getPath());
                }
            }
        } else {
            if (!args.length) {
                const required = this.getArguments().filter((expectedArg)=>!expectedArg.optionalValue).map((expectedArg)=>expectedArg.name);
                if (required.length) {
                    const optionNames = Object.keys(options);
                    const hasStandaloneOption = !!optionNames.find((name)=>this.getOption(name, true)?.standalone);
                    if (!hasStandaloneOption) {
                        throw new MissingArgumentsError(required);
                    }
                }
            } else {
                for (const expectedArg of this.getArguments()){
                    if (!args.length) {
                        if (expectedArg.optionalValue) {
                            break;
                        }
                        throw new MissingArgumentError(expectedArg.name);
                    }
                    let arg;
                    const parseArgValue = (value)=>{
                        return expectedArg.list ? value.split(",").map((value)=>parseArgType(value)) : parseArgType(value);
                    };
                    const parseArgType = (value)=>{
                        return this.parseType({
                            label: "Argument",
                            type: expectedArg.type,
                            name: expectedArg.name,
                            value
                        });
                    };
                    if (expectedArg.variadic) {
                        arg = args.splice(0, args.length).map((value)=>parseArgValue(value));
                    } else {
                        arg = parseArgValue(args.shift());
                    }
                    if (expectedArg.variadic && Array.isArray(arg)) {
                        params.push(...arg);
                    } else if (typeof arg !== "undefined") {
                        params.push(arg);
                    }
                }
                if (args.length) {
                    throw new TooManyArgumentsError(args);
                }
            }
        }
        return params;
    }
    handleError(error) {
        this.throw(error instanceof ValidationError ? new ValidationError1(error.message) : error instanceof Error ? error : new Error(`[non-error-thrown] ${error}`));
    }
    throw(error) {
        if (error instanceof ValidationError1) {
            error.cmd = this;
        }
        this.getErrorHandler()?.(error, this);
        if (this.shouldThrowErrors() || !(error instanceof ValidationError1)) {
            throw error;
        }
        this.showHelp();
        console.error(red(`  ${bold("error")}: ${error.message}\n`));
        Deno.exit(error instanceof ValidationError1 ? error.exitCode : 1);
    }
    getName() {
        return this._name;
    }
    getParent() {
        return this._parent;
    }
    getGlobalParent() {
        return this._globalParent;
    }
    getMainCommand() {
        return this._parent?.getMainCommand() ?? this;
    }
    getAliases() {
        return this.aliases;
    }
    getPath() {
        return this._parent ? this._parent.getPath() + " " + this._name : this._name;
    }
    getArgsDefinition() {
        return this.argsDefinition;
    }
    getArgument(name) {
        return this.getArguments().find((arg)=>arg.name === name);
    }
    getArguments() {
        if (!this.args.length && this.argsDefinition) {
            this.args = parseArgumentsDefinition(this.argsDefinition);
        }
        return this.args;
    }
    hasArguments() {
        return !!this.argsDefinition;
    }
    getVersion() {
        return this.getVersionHandler()?.call(this, this);
    }
    getVersionHandler() {
        return this.ver ?? this._parent?.getVersionHandler();
    }
    getDescription() {
        return typeof this.desc === "function" ? this.desc = this.desc() : this.desc;
    }
    getUsage() {
        return this._usage ?? this.getArgsDefinition();
    }
    getShortDescription() {
        return getDescription(this.getDescription(), true);
    }
    getRawArgs() {
        return this.rawArgs;
    }
    getLiteralArgs() {
        return this.literalArgs;
    }
    showVersion() {
        console.log(this.getVersion());
    }
    getLongVersion() {
        return `${bold(this.getMainCommand().getName())} ${brightBlue(this.getVersion() ?? "")}` + Object.entries(this.getMeta()).map(([k, v])=>`\n${bold(k)} ${brightBlue(v)}`).join("");
    }
    showLongVersion() {
        console.log(this.getLongVersion());
    }
    showHelp(options) {
        console.log(this.getHelp(options));
    }
    getHelp(options) {
        this.registerDefaults();
        return this.getHelpHandler().call(this, this, options ?? {});
    }
    getHelpHandler() {
        return this._help ?? this._parent?.getHelpHandler();
    }
    exit(code = 0) {
        if (this.shouldExit()) {
            Deno.exit(code);
        }
    }
    async checkVersion() {
        const mainCommand = this.getMainCommand();
        const upgradeCommand = mainCommand.getCommand("upgrade");
        if (!isUpgradeCommand(upgradeCommand)) {
            return;
        }
        const latestVersion = await upgradeCommand.getLatestVersion();
        const currentVersion = mainCommand.getVersion();
        if (currentVersion === latestVersion) {
            return;
        }
        const versionHelpText = `(New version available: ${latestVersion}. Run '${mainCommand.getName()} upgrade' to upgrade to the latest version!)`;
        mainCommand.version(`${currentVersion}  ${bold(yellow(versionHelpText))}`);
    }
    hasOptions(hidden) {
        return this.getOptions(hidden).length > 0;
    }
    getOptions(hidden) {
        return this.getGlobalOptions(hidden).concat(this.getBaseOptions(hidden));
    }
    getBaseOptions(hidden) {
        if (!this.options.length) {
            return [];
        }
        return hidden ? this.options.slice(0) : this.options.filter((opt)=>!opt.hidden);
    }
    getGlobalOptions(hidden) {
        const helpOption = this.getHelpOption();
        const getGlobals = (cmd, noGlobals, options = [], names = [])=>{
            if (cmd.options.length) {
                for (const option of cmd.options){
                    if (option.global && !this.options.find((opt)=>opt.name === option.name) && names.indexOf(option.name) === -1 && (hidden || !option.hidden)) {
                        if (noGlobals && option !== helpOption) {
                            continue;
                        }
                        names.push(option.name);
                        options.push(option);
                    }
                }
            }
            return cmd._parent ? getGlobals(cmd._parent, noGlobals || cmd._noGlobals, options, names) : options;
        };
        return this._parent ? getGlobals(this._parent, this._noGlobals) : [];
    }
    hasOption(name, hidden) {
        return !!this.getOption(name, hidden);
    }
    getOption(name, hidden) {
        return this.getBaseOption(name, hidden) ?? this.getGlobalOption(name, hidden);
    }
    getBaseOption(name, hidden) {
        const option = this.options.find((option)=>option.name === name || option.aliases?.includes(name));
        return option && (hidden || !option.hidden) ? option : undefined;
    }
    getGlobalOption(name, hidden) {
        const helpOption = this.getHelpOption();
        const getGlobalOption = (parent, noGlobals)=>{
            const option = parent.getBaseOption(name, hidden);
            if (!option?.global) {
                return parent._parent && getGlobalOption(parent._parent, noGlobals || parent._noGlobals);
            }
            if (noGlobals && option !== helpOption) {
                return;
            }
            return option;
        };
        return this._parent && getGlobalOption(this._parent, this._noGlobals);
    }
    removeOption(name) {
        const index = this.options.findIndex((option)=>option.name === name);
        if (index === -1) {
            return;
        }
        return this.options.splice(index, 1)[0];
    }
    hasCommands(hidden) {
        return this.getCommands(hidden).length > 0;
    }
    getCommands(hidden) {
        return this.getGlobalCommands(hidden).concat(this.getBaseCommands(hidden));
    }
    getBaseCommands(hidden) {
        const commands = Array.from(this.commands.values());
        return hidden ? commands : commands.filter((cmd)=>!cmd.isHidden);
    }
    getGlobalCommands(hidden) {
        const getCommands = (command, noGlobals, commands = [], names = [])=>{
            if (command.commands.size) {
                for (const [_, cmd] of command.commands){
                    if (cmd.isGlobal && this !== cmd && !this.commands.has(cmd._name) && names.indexOf(cmd._name) === -1 && (hidden || !cmd.isHidden)) {
                        if (noGlobals && cmd?.getName() !== "help") {
                            continue;
                        }
                        names.push(cmd._name);
                        commands.push(cmd);
                    }
                }
            }
            return command._parent ? getCommands(command._parent, noGlobals || command._noGlobals, commands, names) : commands;
        };
        return this._parent ? getCommands(this._parent, this._noGlobals) : [];
    }
    hasCommand(name, hidden) {
        return !!this.getCommand(name, hidden);
    }
    getCommand(name, hidden) {
        return this.getBaseCommand(name, hidden) ?? this.getGlobalCommand(name, hidden);
    }
    getBaseCommand(name, hidden) {
        for (const cmd of this.commands.values()){
            if (cmd._name === name || cmd.aliases.includes(name)) {
                return cmd && (hidden || !cmd.isHidden) ? cmd : undefined;
            }
        }
    }
    getGlobalCommand(name, hidden) {
        const getGlobalCommand = (parent, noGlobals)=>{
            const cmd = parent.getBaseCommand(name, hidden);
            if (!cmd?.isGlobal) {
                return parent._parent && getGlobalCommand(parent._parent, noGlobals || parent._noGlobals);
            }
            if (noGlobals && cmd.getName() !== "help") {
                return;
            }
            return cmd;
        };
        return this._parent && getGlobalCommand(this._parent, this._noGlobals);
    }
    removeCommand(name) {
        const command = this.getBaseCommand(name, true);
        if (command) {
            this.commands.delete(command._name);
        }
        return command;
    }
    getTypes() {
        return this.getGlobalTypes().concat(this.getBaseTypes());
    }
    getBaseTypes() {
        return Array.from(this.types.values());
    }
    getGlobalTypes() {
        const getTypes = (cmd, types = [], names = [])=>{
            if (cmd) {
                if (cmd.types.size) {
                    cmd.types.forEach((type)=>{
                        if (type.global && !this.types.has(type.name) && names.indexOf(type.name) === -1) {
                            names.push(type.name);
                            types.push(type);
                        }
                    });
                }
                return getTypes(cmd._parent, types, names);
            }
            return types;
        };
        return getTypes(this._parent);
    }
    getType(name) {
        return this.getBaseType(name) ?? this.getGlobalType(name);
    }
    getBaseType(name) {
        return this.types.get(name);
    }
    getGlobalType(name) {
        if (!this._parent) {
            return;
        }
        const cmd = this._parent.getBaseType(name);
        if (!cmd?.global) {
            return this._parent.getGlobalType(name);
        }
        return cmd;
    }
    getCompletions() {
        return this.getGlobalCompletions().concat(this.getBaseCompletions());
    }
    getBaseCompletions() {
        return Array.from(this.completions.values());
    }
    getGlobalCompletions() {
        const getCompletions = (cmd, completions = [], names = [])=>{
            if (cmd) {
                if (cmd.completions.size) {
                    cmd.completions.forEach((completion)=>{
                        if (completion.global && !this.completions.has(completion.name) && names.indexOf(completion.name) === -1) {
                            names.push(completion.name);
                            completions.push(completion);
                        }
                    });
                }
                return getCompletions(cmd._parent, completions, names);
            }
            return completions;
        };
        return getCompletions(this._parent);
    }
    getCompletion(name) {
        return this.getBaseCompletion(name) ?? this.getGlobalCompletion(name);
    }
    getBaseCompletion(name) {
        return this.completions.get(name);
    }
    getGlobalCompletion(name) {
        if (!this._parent) {
            return;
        }
        const completion = this._parent.getBaseCompletion(name);
        if (!completion?.global) {
            return this._parent.getGlobalCompletion(name);
        }
        return completion;
    }
    hasEnvVars(hidden) {
        return this.getEnvVars(hidden).length > 0;
    }
    getEnvVars(hidden) {
        return this.getGlobalEnvVars(hidden).concat(this.getBaseEnvVars(hidden));
    }
    getBaseEnvVars(hidden) {
        if (!this.envVars.length) {
            return [];
        }
        return hidden ? this.envVars.slice(0) : this.envVars.filter((env)=>!env.hidden);
    }
    getGlobalEnvVars(hidden) {
        if (this._noGlobals) {
            return [];
        }
        const getEnvVars = (cmd, envVars = [], names = [])=>{
            if (cmd) {
                if (cmd.envVars.length) {
                    cmd.envVars.forEach((envVar)=>{
                        if (envVar.global && !this.envVars.find((env)=>env.names[0] === envVar.names[0]) && names.indexOf(envVar.names[0]) === -1 && (hidden || !envVar.hidden)) {
                            names.push(envVar.names[0]);
                            envVars.push(envVar);
                        }
                    });
                }
                return getEnvVars(cmd._parent, envVars, names);
            }
            return envVars;
        };
        return getEnvVars(this._parent);
    }
    hasEnvVar(name, hidden) {
        return !!this.getEnvVar(name, hidden);
    }
    getEnvVar(name, hidden) {
        return this.getBaseEnvVar(name, hidden) ?? this.getGlobalEnvVar(name, hidden);
    }
    getBaseEnvVar(name, hidden) {
        const envVar = this.envVars.find((env)=>env.names.indexOf(name) !== -1);
        return envVar && (hidden || !envVar.hidden) ? envVar : undefined;
    }
    getGlobalEnvVar(name, hidden) {
        if (!this._parent || this._noGlobals) {
            return;
        }
        const envVar = this._parent.getBaseEnvVar(name, hidden);
        if (!envVar?.global) {
            return this._parent.getGlobalEnvVar(name, hidden);
        }
        return envVar;
    }
    hasExamples() {
        return this.examples.length > 0;
    }
    getExamples() {
        return this.examples;
    }
    hasExample(name) {
        return !!this.getExample(name);
    }
    getExample(name) {
        return this.examples.find((example)=>example.name === name);
    }
    getHelpOption() {
        return this._helpOption ?? this._parent?.getHelpOption();
    }
}
function isUpgradeCommand(command) {
    return command instanceof Command && "getLatestVersion" in command;
}
class BashCompletionsGenerator {
    cmd;
    static generate(cmd) {
        return new BashCompletionsGenerator(cmd).generate();
    }
    constructor(cmd){
        this.cmd = cmd;
    }
    generate() {
        const path = this.cmd.getPath();
        const version = this.cmd.getVersion() ? ` v${this.cmd.getVersion()}` : "";
        return `#!/usr/bin/env bash
# bash completion support for ${path}${version}

_${replaceSpecialChars(path)}() {
  local word cur prev listFiles
  local -a opts
  COMPREPLY=()
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"
  cmd="_"
  opts=()
  listFiles=0

  _${replaceSpecialChars(this.cmd.getName())}_complete() {
    local action="$1"; shift
    mapfile -t values < <( ${this.cmd.getName()} completions complete "\${action}" "\${@}" )
    for i in "\${values[@]}"; do
      opts+=("$i")
    done
  }

  _${replaceSpecialChars(this.cmd.getName())}_expand() {
    [ "$cur" != "\${cur%\\\\}" ] && cur="$cur\\\\"
  
    # expand ~username type directory specifications
    if [[ "$cur" == \\~*/* ]]; then
      # shellcheck disable=SC2086
      eval cur=$cur
      
    elif [[ "$cur" == \\~* ]]; then
      cur=\${cur#\\~}
      # shellcheck disable=SC2086,SC2207
      COMPREPLY=( $( compgen -P '~' -u $cur ) )
      return \${#COMPREPLY[@]}
    fi
  }

  # shellcheck disable=SC2120
  _${replaceSpecialChars(this.cmd.getName())}_file_dir() {
    listFiles=1
    local IFS=$'\\t\\n' xspec #glob
    _${replaceSpecialChars(this.cmd.getName())}_expand || return 0
  
    if [ "\${1:-}" = -d ]; then
      # shellcheck disable=SC2206,SC2207,SC2086
      COMPREPLY=( \${COMPREPLY[@]:-} $( compgen -d -- $cur ) )
      #eval "$glob"    # restore glob setting.
      return 0
    fi
  
    xspec=\${1:+"!*.$1"}	# set only if glob passed in as $1
    # shellcheck disable=SC2206,SC2207
    COMPREPLY=( \${COMPREPLY[@]:-} $( compgen -f -X "$xspec" -- "$cur" ) \
          $( compgen -d -- "$cur" ) )
  }

  ${this.generateCompletions(this.cmd).trim()}

  for word in "\${COMP_WORDS[@]}"; do
    case "\${word}" in
      -*) ;;
      *)
        cmd_tmp="\${cmd}_\${word//[^[:alnum:]]/_}"
        if type "\${cmd_tmp}" &>/dev/null; then
          cmd="\${cmd_tmp}"
        fi
    esac
  done

  \${cmd}

  if [[ listFiles -eq 1 ]]; then
    return 0
  fi

  if [[ \${#opts[@]} -eq 0 ]]; then
    # shellcheck disable=SC2207
    COMPREPLY=($(compgen -f "\${cur}"))
    return 0
  fi

  local values
  values="$( printf "\\n%s" "\${opts[@]}" )"
  local IFS=$'\\n'
  # shellcheck disable=SC2207
  local result=($(compgen -W "\${values[@]}" -- "\${cur}"))
  if [[ \${#result[@]} -eq 0 ]]; then
    # shellcheck disable=SC2207
    COMPREPLY=($(compgen -f "\${cur}"))
  else
    # shellcheck disable=SC2207
    COMPREPLY=($(printf '%q\\n' "\${result[@]}"))
  fi

  return 0
}

complete -F _${replaceSpecialChars(path)} -o bashdefault -o default ${path}`;
    }
    generateCompletions(command, path = "", index = 1) {
        path = (path ? path + " " : "") + command.getName();
        const commandCompletions = this.generateCommandCompletions(command, path, index);
        const childCommandCompletions = command.getCommands(false).filter((subCommand)=>subCommand !== command).map((subCommand)=>this.generateCompletions(subCommand, path, index + 1)).join("");
        return `${commandCompletions}

${childCommandCompletions}`;
    }
    generateCommandCompletions(command, path, index) {
        const flags = this.getFlags(command);
        const childCommandNames = command.getCommands(false).map((childCommand)=>childCommand.getName());
        const completionsPath = ~path.indexOf(" ") ? " " + path.split(" ").slice(1).join(" ") : "";
        const optionArguments = this.generateOptionArguments(command, completionsPath);
        const completionsCmd = this.generateCommandCompletionsCommand(command, completionsPath);
        return `  __${replaceSpecialChars(path)}() {
    opts=(${[
            ...flags,
            ...childCommandNames
        ].join(" ")})
    ${completionsCmd}
    if [[ \${cur} == -* || \${COMP_CWORD} -eq ${index} ]] ; then
      return 0
    fi
    ${optionArguments}
  }`;
    }
    getFlags(command) {
        return command.getOptions(false).map((option)=>option.flags).flat();
    }
    generateOptionArguments(command, completionsPath) {
        let opts = "";
        const options = command.getOptions(false);
        if (options.length) {
            opts += 'case "${prev}" in';
            for (const option of options){
                const flags = option.flags.map((flag)=>flag.trim()).join("|");
                const completionsCmd = this.generateOptionCompletionsCommand(command, option.args, completionsPath, {
                    standalone: option.standalone
                });
                opts += `\n      ${flags}) ${completionsCmd} ;;`;
            }
            opts += "\n    esac";
        }
        return opts;
    }
    generateCommandCompletionsCommand(command, path) {
        const args = command.getArguments();
        if (args.length) {
            const type = command.getType(args[0].type);
            if (type && type.handler instanceof FileType) {
                return `_${replaceSpecialChars(this.cmd.getName())}_file_dir`;
            }
            return `_${replaceSpecialChars(this.cmd.getName())}_complete ${args[0].action}${path}`;
        }
        return "";
    }
    generateOptionCompletionsCommand(command, args, path, opts) {
        if (args.length) {
            const type = command.getType(args[0].type);
            if (type && type.handler instanceof FileType) {
                return `opts=(); _${replaceSpecialChars(this.cmd.getName())}_file_dir`;
            }
            return `opts=(); _${replaceSpecialChars(this.cmd.getName())}_complete ${args[0].action}${path}`;
        }
        if (opts?.standalone) {
            return "opts=()";
        }
        return "";
    }
}
function replaceSpecialChars(str) {
    return str.replace(/[^a-zA-Z0-9]/g, "_");
}
class BashCompletionsCommand extends Command {
    #cmd;
    constructor(cmd){
        super();
        this.#cmd = cmd;
        return this.description(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            return `Generate shell completions for bash.

To enable bash completions for this program add following line to your ${dim(italic("~/.bashrc"))}:

    ${dim(italic(`source <(${baseCmd.getPath()} completions bash)`))}`;
        }).noGlobals().action(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            console.log(BashCompletionsGenerator.generate(baseCmd));
        });
    }
}
class CompleteCommand extends Command {
    constructor(cmd){
        super();
        return this.description("Get completions for given action from given command.").noGlobals().arguments("<action:string> [command...:string]").action(async (_, action, ...commandNames)=>{
            let parent;
            const completeCommand = commandNames?.reduce((cmd, name)=>{
                parent = cmd;
                const childCmd = cmd.getCommand(name, false);
                if (!childCmd) {
                    throw new UnknownCompletionCommandError(name, cmd.getCommands());
                }
                return childCmd;
            }, cmd || this.getMainCommand()) ?? (cmd || this.getMainCommand());
            const completion = completeCommand.getCompletion(action);
            const result = await completion?.complete(completeCommand, parent) ?? [];
            if (result?.length) {
                Deno.stdout.writeSync(new TextEncoder().encode(result.join("\n")));
            }
        }).reset();
    }
}
class FishCompletionsGenerator {
    cmd;
    static generate(cmd) {
        return new FishCompletionsGenerator(cmd).generate();
    }
    constructor(cmd){
        this.cmd = cmd;
    }
    generate() {
        const path = this.cmd.getPath();
        const version = this.cmd.getVersion() ? ` v${this.cmd.getVersion()}` : "";
        return `#!/usr/bin/env fish
# fish completion support for ${path}${version}

function __fish_${replaceSpecialChars1(this.cmd.getName())}_using_command
  set -l cmds ${getCommandFnNames(this.cmd).join(" ")}
  set -l words (commandline -opc)
  set -l cmd "_"
  for word in $words
    switch $word
      case '-*'
        continue
      case '*'
        set word (string replace -r -a '\\W' '_' $word)
        set -l cmd_tmp $cmd"_$word"
        if contains $cmd_tmp $cmds
          set cmd $cmd_tmp
        end
    end
  end
  if test "$cmd" = "$argv[1]"
    return 0
  end
  return 1
end

${this.generateCompletions(this.cmd).trim()}`;
    }
    generateCompletions(command) {
        const parent = command.getParent();
        let result = ``;
        if (parent) {
            result += "\n" + this.complete(parent, {
                description: command.getShortDescription(),
                arguments: command.getName()
            });
        }
        const commandArgs = command.getArguments();
        if (commandArgs.length) {
            result += "\n" + this.complete(command, {
                arguments: commandArgs.length ? this.getCompletionCommand(command, commandArgs[0]) : undefined
            });
        }
        for (const option of command.getOptions(false)){
            result += "\n" + this.completeOption(command, option);
        }
        for (const subCommand of command.getCommands(false)){
            result += this.generateCompletions(subCommand);
        }
        return result;
    }
    completeOption(command, option) {
        const shortOption = option.flags.find((flag)=>flag.length === 2)?.replace(/^(-)+/, "");
        const longOption = option.flags.find((flag)=>flag.length > 2)?.replace(/^(-)+/, "");
        return this.complete(command, {
            description: getDescription(option.description),
            shortOption: shortOption,
            longOption: longOption,
            required: true,
            standalone: option.standalone,
            arguments: option.args.length ? this.getCompletionCommand(command, option.args[0]) : undefined
        });
    }
    complete(command, options) {
        const cmd = [
            "complete"
        ];
        cmd.push("-c", this.cmd.getName());
        cmd.push("-n", `'__fish_${replaceSpecialChars1(this.cmd.getName())}_using_command __${replaceSpecialChars1(command.getPath())}'`);
        options.shortOption && cmd.push("-s", options.shortOption);
        options.longOption && cmd.push("-l", options.longOption);
        options.standalone && cmd.push("-x");
        cmd.push("-k");
        cmd.push("-f");
        if (options.arguments) {
            options.required && cmd.push("-r");
            cmd.push("-a", options.arguments);
        }
        if (options.description) {
            const description = getDescription(options.description, true).replace(/'/g, "\\'");
            cmd.push("-d", `'${description}'`);
        }
        return cmd.join(" ");
    }
    getCompletionCommand(cmd, arg) {
        const type = cmd.getType(arg.type);
        if (type && type.handler instanceof FileType) {
            return `'(__fish_complete_path)'`;
        }
        return `'(${this.cmd.getName()} completions complete ${arg.action + " " + getCompletionsPath(cmd)})'`;
    }
}
function getCommandFnNames(cmd, cmds = []) {
    cmds.push(`__${replaceSpecialChars1(cmd.getPath())}`);
    cmd.getCommands(false).forEach((command)=>{
        getCommandFnNames(command, cmds);
    });
    return cmds;
}
function getCompletionsPath(command) {
    return command.getPath().split(" ").slice(1).join(" ");
}
function replaceSpecialChars1(str) {
    return str.replace(/[^a-zA-Z0-9]/g, "_");
}
class FishCompletionsCommand extends Command {
    #cmd;
    constructor(cmd){
        super();
        this.#cmd = cmd;
        return this.description(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            return `Generate shell completions for fish.

To enable fish completions for this program add following line to your ${dim(italic("~/.config/fish/config.fish"))}:

    ${dim(italic(`source (${baseCmd.getPath()} completions fish | psub)`))}`;
        }).noGlobals().action(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            console.log(FishCompletionsGenerator.generate(baseCmd));
        });
    }
}
class ZshCompletionsGenerator {
    cmd;
    actions;
    static generate(cmd) {
        return new ZshCompletionsGenerator(cmd).generate();
    }
    constructor(cmd){
        this.cmd = cmd;
        this.actions = new Map();
    }
    generate() {
        const path = this.cmd.getPath();
        const name = this.cmd.getName();
        const version = this.cmd.getVersion() ? ` v${this.cmd.getVersion()}` : "";
        return `#!/usr/bin/env zsh
# zsh completion support for ${path}${version}

autoload -U is-at-least

# shellcheck disable=SC2154
(( $+functions[__${replaceSpecialChars2(name)}_complete] )) ||
function __${replaceSpecialChars2(name)}_complete {
  local name="$1"; shift
  local action="$1"; shift
  integer ret=1
  local -a values
  local expl lines
  _tags "$name"
  while _tags; do
    if _requested "$name"; then
      # shellcheck disable=SC2034
      lines="$(${name} completions complete "\${action}" "\${@}")"
      values=("\${(ps:\\n:)lines}")
      if (( \${#values[@]} )); then
        while _next_label "$name" expl "$action"; do
          compadd -S '' "\${expl[@]}" "\${values[@]}"
        done
      fi
    fi
  done
}

${this.generateCompletions(this.cmd).trim()}

# _${replaceSpecialChars2(path)} "\${@}"

compdef _${replaceSpecialChars2(path)} ${path}`;
    }
    generateCompletions(command, path = "") {
        if (!command.hasCommands(false) && !command.hasOptions(false) && !command.hasArguments()) {
            return "";
        }
        path = (path ? path + " " : "") + command.getName();
        return `# shellcheck disable=SC2154
(( $+functions[_${replaceSpecialChars2(path)}] )) ||
function _${replaceSpecialChars2(path)}() {` + (!command.getParent() ? `
  local state` : "") + this.generateCommandCompletions(command, path) + this.generateSubCommandCompletions(command, path) + this.generateArgumentCompletions(command, path) + this.generateActions(command) + `\n}\n\n` + command.getCommands(false).filter((subCommand)=>subCommand !== command).map((subCommand)=>this.generateCompletions(subCommand, path)).join("");
    }
    generateCommandCompletions(command, path) {
        const commands = command.getCommands(false);
        let completions = commands.map((subCommand)=>`'${subCommand.getName()}:${subCommand.getShortDescription().replace(/'/g, "'\"'\"'")}'`).join("\n      ");
        if (completions) {
            completions = `
    local -a commands
    # shellcheck disable=SC2034
    commands=(
      ${completions}
    )
    _describe 'command' commands`;
        }
        if (command.hasArguments()) {
            const completionsPath = path.split(" ").slice(1).join(" ");
            const arg = command.getArguments()[0];
            const action = this.addAction(arg, completionsPath);
            if (action && command.getCompletion(arg.action)) {
                completions += `\n    __${replaceSpecialChars2(this.cmd.getName())}_complete ${action.arg.name} ${action.arg.action} ${action.cmd}`;
            }
        }
        if (completions) {
            completions = `\n\n  function _commands() {${completions}\n  }`;
        }
        return completions;
    }
    generateSubCommandCompletions(command, path) {
        if (command.hasCommands(false)) {
            const actions = command.getCommands(false).map((command)=>`${command.getName()}) _${replaceSpecialChars2(path + " " + command.getName())} ;;`).join("\n      ");
            return `\n
  function _command_args() {
    case "\${words[1]}" in\n      ${actions}\n    esac
  }`;
        }
        return "";
    }
    generateArgumentCompletions(command, path) {
        this.actions.clear();
        const options = this.generateOptions(command, path);
        let argIndex = 0;
        let argsCommand = "\n\n  _arguments -w -s -S -C";
        if (command.hasOptions()) {
            argsCommand += ` \\\n    ${options.join(" \\\n    ")}`;
        }
        if (command.hasCommands(false) || command.getArguments().filter((arg)=>command.getCompletion(arg.action)).length) {
            argsCommand += ` \\\n    '${++argIndex}:command:_commands'`;
        }
        if (command.hasArguments() || command.hasCommands(false)) {
            const args = [];
            for (const arg of command.getArguments().slice(1)){
                const type = command.getType(arg.type);
                if (type && type.handler instanceof FileType) {
                    const fileCompletions = this.getFileCompletions(type);
                    if (arg.variadic) {
                        argIndex++;
                        for(let i = 0; i < 5; i++){
                            args.push(`${argIndex + i}${arg.optionalValue ? "::" : ":"}${arg.name}:${fileCompletions}`);
                        }
                    } else {
                        args.push(`${++argIndex}${arg.optionalValue ? "::" : ":"}${arg.name}:${fileCompletions}`);
                    }
                } else {
                    const completionsPath = path.split(" ").slice(1).join(" ");
                    const action = this.addAction(arg, completionsPath);
                    args.push(`${++argIndex}${arg.optionalValue ? "::" : ":"}${arg.name}:->${action.name}`);
                }
            }
            argsCommand += args.map((arg)=>`\\\n    '${arg}'`).join("");
            if (command.hasCommands(false)) {
                argsCommand += ` \\\n    '*::sub command:->command_args'`;
            }
        }
        return argsCommand;
    }
    generateOptions(command, path) {
        const options = [];
        const cmdArgs = path.split(" ");
        cmdArgs.shift();
        const completionsPath = cmdArgs.join(" ");
        const excludedFlags = command.getOptions(false).map((option)=>option.standalone ? option.flags : false).flat().filter((flag)=>typeof flag === "string");
        for (const option of command.getOptions(false)){
            options.push(this.generateOption(command, option, completionsPath, excludedFlags));
        }
        return options;
    }
    generateOption(command, option, completionsPath, excludedOptions) {
        let args = "";
        for (const arg of option.args){
            const type = command.getType(arg.type);
            const optionalValue = arg.optionalValue ? "::" : ":";
            if (type && type.handler instanceof FileType) {
                const fileCompletions = this.getFileCompletions(type);
                args += `${optionalValue}${arg.name}:${fileCompletions}`;
            } else {
                const action = this.addAction(arg, completionsPath);
                args += `${optionalValue}${arg.name}:->${action.name}`;
            }
        }
        const description = getDescription(option.description, true).replace(/\[/g, "\\[").replace(/]/g, "\\]").replace(/"/g, '\\"').replace(/'/g, "'\"'\"'");
        const collect = option.collect ? "*" : "";
        const equalsSign = option.equalsSign ? "=" : "";
        const flags = option.flags.map((flag)=>`${flag}${equalsSign}`);
        let result = "";
        if (option.standalone) {
            result += "'(- *)'";
        } else {
            const excludedFlags = [
                ...excludedOptions
            ];
            if (option.conflicts?.length) {
                excludedFlags.push(...option.conflicts.map((opt)=>"--" + opt.replace(/^--/, "")));
            }
            if (!option.collect) {
                excludedFlags.push(...option.flags);
            }
            if (excludedFlags.length) {
                result += `'(${excludedFlags.join(" ")})'`;
            }
        }
        if (collect || flags.length > 1) {
            result += `{${collect}${flags.join(",")}}`;
        } else {
            result += `${flags.join(",")}`;
        }
        return `${result}'[${description}]${args}'`;
    }
    getFileCompletions(type) {
        if (!(type.handler instanceof FileType)) {
            return "";
        }
        return "_files";
    }
    addAction(arg, cmd) {
        const action = `${arg.name}-${arg.action}`;
        if (!this.actions.has(action)) {
            this.actions.set(action, {
                arg: arg,
                label: `${arg.name}: ${arg.action}`,
                name: action,
                cmd
            });
        }
        return this.actions.get(action);
    }
    generateActions(command) {
        let actions = [];
        if (this.actions.size) {
            actions = Array.from(this.actions).map(([name, action])=>`${name}) __${replaceSpecialChars2(this.cmd.getName())}_complete ${action.arg.name} ${action.arg.action} ${action.cmd} ;;`);
        }
        if (command.hasCommands(false)) {
            actions.unshift(`command_args) _command_args ;;`);
        }
        if (actions.length) {
            return `\n\n  case "$state" in\n    ${actions.join("\n    ")}\n  esac`;
        }
        return "";
    }
}
function replaceSpecialChars2(str) {
    return str.replace(/[^a-zA-Z0-9]/g, "_");
}
class ZshCompletionsCommand extends Command {
    #cmd;
    constructor(cmd){
        super();
        this.#cmd = cmd;
        return this.description(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            return `Generate shell completions for zsh.

To enable zsh completions for this program add following line to your ${dim(italic("~/.zshrc"))}:

    ${dim(italic(`source <(${baseCmd.getPath()} completions zsh)`))}`;
        }).noGlobals().action(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            console.log(ZshCompletionsGenerator.generate(baseCmd));
        });
    }
}
class CompletionsCommand extends Command {
    #cmd;
    constructor(cmd){
        super();
        this.#cmd = cmd;
        return this.description(()=>{
            const baseCmd = this.#cmd || this.getMainCommand();
            return `Generate shell completions.

To enable shell completions for this program add the following line to your ${dim(italic("~/.bashrc"))} or similar:

    ${dim(italic(`source <(${baseCmd.getPath()} completions [shell])`))}

    For more information run ${dim(italic(`${baseCmd.getPath()} completions [shell] --help`))}
`;
        }).noGlobals().action(()=>this.showHelp()).command("bash", new BashCompletionsCommand(this.#cmd)).command("fish", new FishCompletionsCommand(this.#cmd)).command("zsh", new ZshCompletionsCommand(this.#cmd)).command("complete", new CompleteCommand(this.#cmd).hidden()).reset();
    }
}
class Provider {
    maxListSize = 25;
    maxCols = 8;
    async isOutdated(name, currentVersion, targetVersion) {
        const { latest , versions  } = await this.getVersions(name);
        if (targetVersion === "latest") {
            targetVersion = latest;
        }
        if (targetVersion && !versions.includes(targetVersion)) {
            throw new ValidationError1(`The provided version ${bold(red(targetVersion))} is not found.\n\n    ${cyan(`Visit ${brightBlue(this.getRepositoryUrl(name))} for available releases or run again with the ${yellow("-l")} or ${yellow("--list-versions")} command.`)}`);
        }
        if (latest && latest === currentVersion && latest === targetVersion) {
            console.warn(yellow(`You're already using the latest available version ${currentVersion} of ${name}.`));
            return false;
        }
        if (targetVersion && currentVersion === targetVersion) {
            console.warn(yellow(`You're already using version ${currentVersion} of ${name}.`));
            return false;
        }
        return true;
    }
    async upgrade({ name , from , to , importMap , main =`${name}.ts` , args =[]  }) {
        if (to === "latest") {
            const { latest  } = await this.getVersions(name);
            to = latest;
        }
        const registry = new URL(main, this.getRegistryUrl(name, to)).href;
        const cmd = [
            Deno.execPath(),
            "install"
        ];
        if (importMap) {
            const importJson = new URL(importMap, this.getRegistryUrl(name, to)).href;
            cmd.push("--import-map", importJson);
        }
        if (args.length) {
            cmd.push(...args, "--force", "--name", name, registry);
        } else {
            cmd.push("--no-check", "--quiet", "--force", "--name", name, registry);
        }
        const process = Deno.run({
            cmd,
            stdout: "piped",
            stderr: "piped"
        });
        const [status, stderr] = await Promise.all([
            process.status(),
            process.stderrOutput(),
            process.output()
        ]);
        if (!status.success) {
            process.close();
            await Deno.stderr.write(stderr);
            throw new Error(`Failed to upgrade ${name} from ${from} to version ${to}!`);
        }
        process.close();
        console.info(`Successfully upgraded ${name} from ${from} to version ${to}! (${this.getRegistryUrl(name, to)})`);
    }
    async listVersions(name, currentVersion) {
        const { versions  } = await this.getVersions(name);
        this.printVersions(versions, currentVersion);
    }
    printVersions(versions, currentVersion, { maxCols =this.maxCols , indent =0  } = {}) {
        versions = versions.slice();
        if (versions?.length) {
            versions = versions.map((version)=>currentVersion && currentVersion === version ? green(`* ${version}`) : `  ${version}`);
            if (versions.length > this.maxListSize) {
                const table = new Table().indent(indent);
                const rowSize = Math.ceil(versions.length / maxCols);
                const colSize = Math.min(versions.length, maxCols);
                let versionIndex = 0;
                for(let colIndex = 0; colIndex < colSize; colIndex++){
                    for(let rowIndex = 0; rowIndex < rowSize; rowIndex++){
                        if (!table[rowIndex]) {
                            table[rowIndex] = [];
                        }
                        table[rowIndex][colIndex] = versions[versionIndex++];
                    }
                }
                console.log(table.toString());
            } else {
                console.log(versions.map((version)=>" ".repeat(indent) + version).join("\n"));
            }
        }
    }
}
class EnumType extends Type {
    allowedValues;
    constructor(values){
        super();
        this.allowedValues = Array.isArray(values) ? values : Object.values(values);
    }
    parse(type) {
        for (const value of this.allowedValues){
            if (value.toString() === type.value) {
                return value;
            }
        }
        throw new InvalidTypeError(type, this.allowedValues.slice());
    }
    values() {
        return this.allowedValues.slice();
    }
    complete() {
        return this.values();
    }
}
class UpgradeCommand extends Command {
    providers;
    constructor({ provider , main , args , importMap  }){
        super();
        this.providers = Array.isArray(provider) ? provider : [
            provider
        ];
        if (!this.providers.length) {
            throw new Error(`No upgrade provider defined!`);
        }
        this.description(()=>`Upgrade ${this.getMainCommand().getName()} executable to latest or given version.`).noGlobals().type("provider", new EnumType(this.getProviderNames())).option("-r, --registry <name:provider>", `The registry name from which to upgrade.`, {
            default: this.getProvider().name,
            hidden: this.providers.length < 2,
            value: (registry)=>this.getProvider(registry)
        }).option("-l, --list-versions", "Show available versions.", {
            action: async ({ registry  })=>{
                await registry.listVersions(this.getMainCommand().getName(), this.getVersion());
                Deno.exit(0);
            }
        }).option("--version <version:string:version>", "The version to upgrade to.", {
            default: "latest"
        }).option("-f, --force", "Replace current installation even if not out-of-date.").complete("version", ()=>this.getAllVersions()).action(async ({ registry , version: targetVersion , force  })=>{
            const name = this.getMainCommand().getName();
            const currentVersion = this.getVersion();
            if (force || !currentVersion || await registry.isOutdated(name, currentVersion, targetVersion)) {
                await registry.upgrade({
                    name,
                    main,
                    importMap,
                    from: currentVersion,
                    to: targetVersion,
                    args
                });
            }
        });
    }
    async getAllVersions() {
        const { versions  } = await this.getVersions();
        return versions;
    }
    async getLatestVersion() {
        const { latest  } = await this.getVersions();
        return latest;
    }
    getVersions() {
        return this.getProvider().getVersions(this.getMainCommand().getName());
    }
    getProvider(name) {
        const provider = name ? this.providers.find((provider)=>provider.name === name) : this.providers[0];
        if (!provider) {
            throw new ValidationError(`Unknown provider "${name}"`);
        }
        return provider;
    }
    getProviderNames() {
        return this.providers.map((provider)=>provider.name);
    }
}
const main = {
    ARROW_UP: "↑",
    ARROW_DOWN: "↓",
    ARROW_LEFT: "←",
    ARROW_RIGHT: "→",
    ARROW_UP_LEFT: "↖",
    ARROW_UP_RIGHT: "↗",
    ARROW_DOWN_RIGHT: "↘",
    ARROW_DOWN_LEFT: "↙",
    RADIO_ON: "◉",
    RADIO_OFF: "◯",
    TICK: "✔",
    CROSS: "✘",
    ELLIPSIS: "…",
    POINTER_SMALL: "›",
    LINE: "─",
    POINTER: "❯",
    INFO: "ℹ",
    TAB_LEFT: "⇤",
    TAB_RIGHT: "⇥",
    ESCAPE: "⎋",
    BACKSPACE: "⌫",
    PAGE_UP: "⇞",
    PAGE_DOWN: "⇟",
    ENTER: "↵",
    SEARCH: "⌕"
};
const win = {
    ...main,
    RADIO_ON: "(*)",
    RADIO_OFF: "( )",
    TICK: "√",
    CROSS: "×",
    POINTER_SMALL: "»"
};
const Figures = Deno.build.os === "windows" ? win : main;
const keyMap = {
    up: "ARROW_UP",
    down: "ARROW_DOWN",
    left: "ARROW_LEFT",
    right: "ARROW_RIGHT",
    pageup: "PAGE_UP",
    pagedown: "PAGE_DOWN",
    tab: "TAB_RIGHT",
    enter: "ENTER",
    return: "ENTER"
};
function getFiguresByKeys(keys) {
    const figures = [];
    for (const key of keys){
        const figure = Figures[keyMap[key]] ?? key;
        if (!figures.includes(figure)) {
            figures.push(figure);
        }
    }
    return figures;
}
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
const ESC = "\x1B";
const CSI = `${ESC}[`;
const OSC = `${ESC}]`;
const SEP = ";";
const bel = "\u0007";
const cursorPosition = `${CSI}6n`;
function cursorTo(x, y) {
    if (typeof y !== "number") {
        return `${CSI}${x}G`;
    }
    return `${CSI}${y};${x}H`;
}
function cursorMove(x, y) {
    let ret = "";
    if (x < 0) {
        ret += `${CSI}${-x}D`;
    } else if (x > 0) {
        ret += `${CSI}${x}C`;
    }
    if (y < 0) {
        ret += `${CSI}${-y}A`;
    } else if (y > 0) {
        ret += `${CSI}${y}B`;
    }
    return ret;
}
function cursorUp(count = 1) {
    return `${CSI}${count}A`;
}
function cursorDown(count = 1) {
    return `${CSI}${count}B`;
}
function cursorForward(count = 1) {
    return `${CSI}${count}C`;
}
function cursorBackward(count = 1) {
    return `${CSI}${count}D`;
}
function cursorNextLine(count = 1) {
    return `${CSI}E`.repeat(count);
}
function cursorPrevLine(count = 1) {
    return `${CSI}F`.repeat(count);
}
const cursorLeft = `${CSI}G`;
const cursorHide = `${CSI}?25l`;
const cursorShow = `${CSI}?25h`;
const cursorSave = `${ESC}7`;
const cursorRestore = `${ESC}8`;
function scrollUp(count = 1) {
    return `${CSI}S`.repeat(count);
}
function scrollDown(count = 1) {
    return `${CSI}T`.repeat(count);
}
const eraseScreen = `${CSI}2J`;
function eraseUp(count = 1) {
    return `${CSI}1J`.repeat(count);
}
function eraseDown(count = 1) {
    return `${CSI}0J`.repeat(count);
}
const eraseLine = `${CSI}2K`;
const eraseLineEnd = `${CSI}0K`;
const eraseLineStart = `${CSI}1K`;
function eraseLines(count) {
    let clear = "";
    for(let i = 0; i < count; i++){
        clear += eraseLine + (i < count - 1 ? cursorUp() : "");
    }
    clear += cursorLeft;
    return clear;
}
const clearScreen = "\u001Bc";
const clearTerminal = Deno.build.os === "windows" ? `${eraseScreen}${CSI}0f` : `${eraseScreen}${CSI}3J${CSI}H`;
function link(text, url) {
    return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        bel,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        bel
    ].join("");
}
function image(buffer, options) {
    let ret = `${OSC}1337;File=inline=1`;
    if (options?.width) {
        ret += `;width=${options.width}`;
    }
    if (options?.height) {
        ret += `;height=${options.height}`;
    }
    if (options?.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
    }
    return ret + ":" + encode(buffer) + bel;
}
const mod1 = {
    bel: bel,
    cursorPosition: cursorPosition,
    cursorTo: cursorTo,
    cursorMove: cursorMove,
    cursorUp: cursorUp,
    cursorDown: cursorDown,
    cursorForward: cursorForward,
    cursorBackward: cursorBackward,
    cursorNextLine: cursorNextLine,
    cursorPrevLine: cursorPrevLine,
    cursorLeft: cursorLeft,
    cursorHide: cursorHide,
    cursorShow: cursorShow,
    cursorSave: cursorSave,
    cursorRestore: cursorRestore,
    scrollUp: scrollUp,
    scrollDown: scrollDown,
    eraseScreen: eraseScreen,
    eraseUp: eraseUp,
    eraseDown: eraseDown,
    eraseLine: eraseLine,
    eraseLineEnd: eraseLineEnd,
    eraseLineStart: eraseLineStart,
    eraseLines: eraseLines,
    clearScreen: clearScreen,
    clearTerminal: clearTerminal,
    link: link,
    image: image
};
function getCursorPosition({ stdin =Deno.stdin , stdout =Deno.stdout  } = {}) {
    const data = new Uint8Array(8);
    Deno.stdin.setRaw(true);
    stdout.writeSync(new TextEncoder().encode(cursorPosition));
    stdin.readSync(data);
    Deno.stdin.setRaw(false);
    const [y, x] = new TextDecoder().decode(data).match(/\[(\d+);(\d+)R/)?.slice(1, 3).map(Number) ?? [
        0,
        0
    ];
    return {
        x,
        y
    };
}
const tty = factory();
function factory(options) {
    let result = "";
    let stack = [];
    const stdout = options?.stdout ?? Deno.stdout;
    const stdin = options?.stdin ?? Deno.stdin;
    const tty = function(...args) {
        if (this) {
            update(args);
            stdout.writeSync(new TextEncoder().encode(result));
            return this;
        }
        return factory(args[0] ?? options);
    };
    tty.text = function(text) {
        stack.push([
            text,
            []
        ]);
        update();
        stdout.writeSync(new TextEncoder().encode(result));
        return this;
    };
    tty.getCursorPosition = ()=>getCursorPosition({
            stdout,
            stdin
        });
    const methodList = Object.entries(mod1);
    for (const [name, method] of methodList){
        if (name === "cursorPosition") {
            continue;
        }
        Object.defineProperty(tty, name, {
            get () {
                stack.push([
                    method,
                    []
                ]);
                return this;
            }
        });
    }
    return tty;
    function update(args) {
        if (!stack.length) {
            return;
        }
        if (args) {
            stack[stack.length - 1][1] = args;
        }
        result = stack.reduce((prev, [cur, args])=>prev + (typeof cur === "string" ? cur : cur.call(tty, ...args)), "");
        stack = [];
    }
}
const KeyMap = {
    "[P": "f1",
    "[Q": "f2",
    "[R": "f3",
    "[S": "f4",
    "OP": "f1",
    "OQ": "f2",
    "OR": "f3",
    "OS": "f4",
    "[11~": "f1",
    "[12~": "f2",
    "[13~": "f3",
    "[14~": "f4",
    "[[A": "f1",
    "[[B": "f2",
    "[[C": "f3",
    "[[D": "f4",
    "[[E": "f5",
    "[15~": "f5",
    "[17~": "f6",
    "[18~": "f7",
    "[19~": "f8",
    "[20~": "f9",
    "[21~": "f10",
    "[23~": "f11",
    "[24~": "f12",
    "[A": "up",
    "[B": "down",
    "[C": "right",
    "[D": "left",
    "[E": "clear",
    "[F": "end",
    "[H": "home",
    "OA": "up",
    "OB": "down",
    "OC": "right",
    "OD": "left",
    "OE": "clear",
    "OF": "end",
    "OH": "home",
    "[1~": "home",
    "[2~": "insert",
    "[3~": "delete",
    "[4~": "end",
    "[5~": "pageup",
    "[6~": "pagedown",
    "[[5~": "pageup",
    "[[6~": "pagedown",
    "[7~": "home",
    "[8~": "end"
};
const KeyMapShift = {
    "[a": "up",
    "[b": "down",
    "[c": "right",
    "[d": "left",
    "[e": "clear",
    "[2$": "insert",
    "[3$": "delete",
    "[5$": "pageup",
    "[6$": "pagedown",
    "[7$": "home",
    "[8$": "end",
    "[Z": "tab"
};
const KeyMapCtrl = {
    "Oa": "up",
    "Ob": "down",
    "Oc": "right",
    "Od": "left",
    "Oe": "clear",
    "[2^": "insert",
    "[3^": "delete",
    "[5^": "pageup",
    "[6^": "pagedown",
    "[7^": "home",
    "[8^": "end"
};
const SpecialKeyMap = {
    "\r": "return",
    "\n": "enter",
    "\t": "tab",
    "\b": "backspace",
    "\x7f": "backspace",
    "\x1b": "escape",
    " ": "space"
};
const kEscape = "\x1b";
function parse1(data) {
    let index = -1;
    const keys = [];
    const input = data instanceof Uint8Array ? new TextDecoder().decode(data) : data;
    const hasNext = ()=>input.length - 1 >= index + 1;
    const next = ()=>input[++index];
    parseNext();
    return keys;
    function parseNext() {
        let ch = next();
        let s = ch;
        let escaped = false;
        const key = {
            name: undefined,
            char: undefined,
            sequence: undefined,
            code: undefined,
            ctrl: false,
            meta: false,
            shift: false
        };
        if (ch === kEscape && hasNext()) {
            escaped = true;
            s += ch = next();
            if (ch === kEscape) {
                s += ch = next();
            }
        }
        if (escaped && (ch === "O" || ch === "[")) {
            let code = ch;
            let modifier = 0;
            if (ch === "O") {
                s += ch = next();
                if (ch >= "0" && ch <= "9") {
                    modifier = (Number(ch) >> 0) - 1;
                    s += ch = next();
                }
                code += ch;
            } else if (ch === "[") {
                s += ch = next();
                if (ch === "[") {
                    code += ch;
                    s += ch = next();
                }
                const cmdStart = s.length - 1;
                if (ch >= "0" && ch <= "9") {
                    s += ch = next();
                    if (ch >= "0" && ch <= "9") {
                        s += ch = next();
                    }
                }
                if (ch === ";") {
                    s += ch = next();
                    if (ch >= "0" && ch <= "9") {
                        s += next();
                    }
                }
                const cmd = s.slice(cmdStart);
                let match;
                if (match = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/)) {
                    code += match[1] + match[4];
                    modifier = (Number(match[3]) || 1) - 1;
                } else if (match = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/)) {
                    code += match[4];
                    modifier = (Number(match[3]) || 1) - 1;
                } else {
                    code += cmd;
                }
            }
            key.ctrl = !!(modifier & 4);
            key.meta = !!(modifier & 10);
            key.shift = !!(modifier & 1);
            key.code = code;
            if (code in KeyMap) {
                key.name = KeyMap[code];
            } else if (code in KeyMapShift) {
                key.name = KeyMapShift[code];
                key.shift = true;
            } else if (code in KeyMapCtrl) {
                key.name = KeyMapCtrl[code];
                key.ctrl = true;
            } else {
                key.name = "undefined";
            }
        } else if (ch in SpecialKeyMap) {
            key.name = SpecialKeyMap[ch];
            key.meta = escaped;
            if (key.name === "space") {
                key.char = ch;
            }
        } else if (!escaped && ch <= "\x1a") {
            key.name = String.fromCharCode(ch.charCodeAt(0) + "a".charCodeAt(0) - 1);
            key.ctrl = true;
            key.char = key.name;
        } else if (/^[0-9A-Za-z]$/.test(ch)) {
            key.name = ch.toLowerCase();
            key.shift = /^[A-Z]$/.test(ch);
            key.meta = escaped;
            key.char = ch;
        } else if (escaped) {
            key.name = ch.length ? undefined : "escape";
            key.meta = true;
        } else {
            key.name = ch;
            key.char = ch;
        }
        key.sequence = s;
        if (s.length !== 0 && (key.name !== undefined || escaped) || charLengthAt(s, 0) === s.length) {
            keys.push(key);
        } else {
            throw new Error("Unrecognized or broken escape sequence");
        }
        if (hasNext()) {
            parseNext();
        }
    }
}
function charLengthAt(str, i) {
    const pos = str.codePointAt(i);
    if (typeof pos === "undefined") {
        return 1;
    }
    return pos >= 0x10000 ? 2 : 1;
}
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse2(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod2 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse2,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename1(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse3(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod3 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse3,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod2 : mod3;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod2 : mod3;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse4 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;
class GenericPrompt {
    static injectedValue;
    settings;
    tty = tty;
    indent;
    cursor = {
        x: 0,
        y: 0
    };
    #value;
    #lastError;
    #isFirstRun = true;
    #encoder = new TextEncoder();
    static inject(value) {
        GenericPrompt.injectedValue = value;
    }
    constructor(settings){
        this.settings = {
            ...settings,
            keys: {
                submit: [
                    "enter",
                    "return"
                ],
                ...settings.keys ?? {}
            }
        };
        this.indent = this.settings.indent ?? " ";
    }
    async prompt() {
        try {
            return await this.#execute();
        } finally{
            this.tty.cursorShow();
        }
    }
    clear() {
        this.tty.cursorLeft.eraseDown();
    }
    #execute = async ()=>{
        if (typeof GenericPrompt.injectedValue !== "undefined" && this.#lastError) {
            throw new Error(this.error());
        }
        await this.render();
        this.#lastError = undefined;
        if (!await this.read()) {
            return this.#execute();
        }
        if (typeof this.#value === "undefined") {
            throw new Error("internal error: failed to read value");
        }
        this.clear();
        const successMessage = this.success(this.#value);
        if (successMessage) {
            console.log(successMessage);
        }
        GenericPrompt.injectedValue = undefined;
        this.tty.cursorShow();
        return this.#value;
    };
    async render() {
        const result = await Promise.all([
            this.message(),
            this.body?.(),
            this.footer()
        ]);
        const content = result.filter(Boolean).join("\n");
        const lines = content.split("\n");
        const columns = getColumns();
        const linesCount = columns ? lines.reduce((prev, next)=>{
            const length = stripColor(next).length;
            return prev + (length > columns ? Math.ceil(length / columns) : 1);
        }, 0) : content.split("\n").length;
        const y = linesCount - this.cursor.y - 1;
        if (!this.#isFirstRun || this.#lastError) {
            this.clear();
        }
        this.#isFirstRun = false;
        if (Deno.build.os === "windows") {
            console.log(content);
            this.tty.cursorUp();
        } else {
            Deno.stdout.writeSync(this.#encoder.encode(content));
        }
        if (y) {
            this.tty.cursorUp(y);
        }
        this.tty.cursorTo(this.cursor.x);
    }
    async read() {
        if (typeof GenericPrompt.injectedValue !== "undefined") {
            const value = GenericPrompt.injectedValue;
            await this.#validateValue(value);
        } else {
            const events = await this.#readKey();
            if (!events.length) {
                return false;
            }
            for (const event of events){
                await this.handleEvent(event);
            }
        }
        return typeof this.#value !== "undefined";
    }
    submit() {
        return this.#validateValue(this.getValue());
    }
    message() {
        return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults();
    }
    defaults() {
        let defaultMessage = "";
        if (typeof this.settings.default !== "undefined" && !this.settings.hideDefault) {
            defaultMessage += dim(` (${this.format(this.settings.default)})`);
        }
        return defaultMessage;
    }
    success(value) {
        return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults() + " " + this.settings.pointer + " " + green(this.format(value));
    }
    footer() {
        return this.error() ?? this.hint();
    }
    error() {
        return this.#lastError ? this.settings.indent + red(bold(`${Figures.CROSS} `) + this.#lastError) : undefined;
    }
    hint() {
        return this.settings.hint ? this.settings.indent + italic(brightBlue(dim(`${Figures.POINTER} `) + this.settings.hint)) : undefined;
    }
    setErrorMessage(message) {
        this.#lastError = message;
    }
    async handleEvent(event) {
        switch(true){
            case event.name === "c" && event.ctrl:
                this.clear();
                this.tty.cursorShow();
                Deno.exit(130);
                return;
            case this.isKey(this.settings.keys, "submit", event):
                await this.submit();
                break;
        }
    }
    #readKey = async ()=>{
        const data = await this.#readChar();
        return data.length ? parse1(data) : [];
    };
    #readChar = async ()=>{
        const buffer = new Uint8Array(8);
        const isTty = Deno.isatty(Deno.stdin.rid);
        if (isTty) {
            Deno.stdin.setRaw(true, {
                cbreak: this.settings.cbreak === true
            });
        }
        const nread = await Deno.stdin.read(buffer);
        if (isTty) {
            Deno.stdin.setRaw(false);
        }
        if (nread === null) {
            return buffer;
        }
        return buffer.subarray(0, nread);
    };
    #transformValue = (value)=>{
        return this.settings.transform ? this.settings.transform(value) : this.transform(value);
    };
    #validateValue = async (value)=>{
        if (!value && typeof this.settings.default !== "undefined") {
            this.#value = this.settings.default;
            return;
        }
        this.#value = undefined;
        this.#lastError = undefined;
        const validation = await (this.settings.validate ? this.settings.validate(value) : this.validate(value));
        if (validation === false) {
            this.#lastError = `Invalid answer.`;
        } else if (typeof validation === "string") {
            this.#lastError = validation;
        } else {
            this.#value = this.#transformValue(value);
        }
    };
    isKey(keys, name, event) {
        const keyNames = keys?.[name];
        return typeof keyNames !== "undefined" && (typeof event.name !== "undefined" && keyNames.indexOf(event.name) !== -1 || typeof event.sequence !== "undefined" && keyNames.indexOf(event.sequence) !== -1);
    }
}
function getColumns() {
    try {
        return Deno.consoleSize(Deno.stdout.rid).columns;
    } catch (_error) {
        return null;
    }
}
class GenericInput extends GenericPrompt {
    inputValue = "";
    inputIndex = 0;
    constructor(settings){
        super({
            ...settings,
            keys: {
                moveCursorLeft: [
                    "left"
                ],
                moveCursorRight: [
                    "right"
                ],
                deleteCharLeft: [
                    "backspace"
                ],
                deleteCharRight: [
                    "delete"
                ],
                ...settings.keys ?? {}
            }
        });
    }
    getCurrentInputValue() {
        return this.inputValue;
    }
    message() {
        const message = super.message() + " " + this.settings.pointer + " ";
        this.cursor.x = stripColor(message).length + this.inputIndex + 1;
        return message + this.input();
    }
    input() {
        return underline(this.inputValue);
    }
    highlight(value, color1 = dim, color2 = brightBlue) {
        value = value.toString();
        const inputLowerCase = this.getCurrentInputValue().toLowerCase();
        const valueLowerCase = value.toLowerCase();
        const index = valueLowerCase.indexOf(inputLowerCase);
        const matched = value.slice(index, index + inputLowerCase.length);
        return index >= 0 ? color1(value.slice(0, index)) + color2(matched) + color1(value.slice(index + inputLowerCase.length)) : value;
    }
    async handleEvent(event) {
        switch(true){
            case this.isKey(this.settings.keys, "moveCursorLeft", event):
                this.moveCursorLeft();
                break;
            case this.isKey(this.settings.keys, "moveCursorRight", event):
                this.moveCursorRight();
                break;
            case this.isKey(this.settings.keys, "deleteCharRight", event):
                this.deleteCharRight();
                break;
            case this.isKey(this.settings.keys, "deleteCharLeft", event):
                this.deleteChar();
                break;
            case event.char && !event.meta && !event.ctrl:
                this.addChar(event.char);
                break;
            default:
                await super.handleEvent(event);
        }
    }
    addChar(__char) {
        this.inputValue = this.inputValue.slice(0, this.inputIndex) + __char + this.inputValue.slice(this.inputIndex);
        this.inputIndex++;
    }
    moveCursorLeft() {
        if (this.inputIndex > 0) {
            this.inputIndex--;
        }
    }
    moveCursorRight() {
        if (this.inputIndex < this.inputValue.length) {
            this.inputIndex++;
        }
    }
    deleteChar() {
        if (this.inputIndex > 0) {
            this.inputIndex--;
            this.deleteCharRight();
        }
    }
    deleteCharRight() {
        if (this.inputIndex < this.inputValue.length) {
            this.inputValue = this.inputValue.slice(0, this.inputIndex) + this.inputValue.slice(this.inputIndex + 1);
        }
    }
}
class GenericList extends GenericInput {
    options = this.settings.options;
    listIndex = this.getListIndex();
    listOffset = this.getPageOffset(this.listIndex);
    static separator(label = "------------") {
        return {
            value: label,
            disabled: true
        };
    }
    static mapOption(option) {
        return {
            value: option.value,
            name: typeof option.name === "undefined" ? option.value : option.name,
            disabled: !!option.disabled
        };
    }
    constructor(settings){
        super({
            ...settings,
            keys: {
                previous: settings.search ? [
                    "up"
                ] : [
                    "up",
                    "u",
                    "p",
                    "8"
                ],
                next: settings.search ? [
                    "down"
                ] : [
                    "down",
                    "d",
                    "n",
                    "2"
                ],
                previousPage: [
                    "pageup",
                    "left"
                ],
                nextPage: [
                    "pagedown",
                    "right"
                ],
                ...settings.keys ?? {}
            }
        });
    }
    match() {
        const input = this.getCurrentInputValue().toLowerCase();
        if (!input.length) {
            this.options = this.settings.options.slice();
        } else {
            this.options = this.settings.options.filter((option)=>match(option.name) || option.name !== option.value && match(option.value)).sort((a, b)=>distance(a.name, input) - distance(b.name, input));
        }
        this.listIndex = Math.max(0, Math.min(this.options.length - 1, this.listIndex));
        this.listOffset = Math.max(0, Math.min(this.options.length - this.getListHeight(), this.listOffset));
        function match(value) {
            return stripColor(value).toLowerCase().includes(input);
        }
    }
    message() {
        let message = `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults();
        if (this.settings.search) {
            message += " " + this.settings.searchLabel + " ";
        }
        this.cursor.x = stripColor(message).length + this.inputIndex + 1;
        return message + this.input();
    }
    body() {
        return this.getList() + this.getInfo();
    }
    getInfo() {
        if (!this.settings.info) {
            return "";
        }
        const selected = this.listIndex + 1;
        const actions = [
            [
                "Next",
                getFiguresByKeys(this.settings.keys?.next ?? [])
            ],
            [
                "Previous",
                getFiguresByKeys(this.settings.keys?.previous ?? [])
            ],
            [
                "Next Page",
                getFiguresByKeys(this.settings.keys?.nextPage ?? [])
            ],
            [
                "Previous Page",
                getFiguresByKeys(this.settings.keys?.previousPage ?? [])
            ],
            [
                "Submit",
                getFiguresByKeys(this.settings.keys?.submit ?? [])
            ]
        ];
        return "\n" + this.settings.indent + brightBlue(Figures.INFO) + bold(` ${selected}/${this.options.length} `) + actions.map((cur)=>`${cur[0]}: ${bold(cur[1].join(", "))}`).join(", ");
    }
    getList() {
        const list = [];
        const height = this.getListHeight();
        for(let i = this.listOffset; i < this.listOffset + height; i++){
            list.push(this.getListItem(this.options[i], this.listIndex === i));
        }
        if (!list.length) {
            list.push(this.settings.indent + dim("  No matches..."));
        }
        return list.join("\n");
    }
    getListHeight() {
        return Math.min(this.options.length, this.settings.maxRows || this.options.length);
    }
    getListIndex(value) {
        return Math.max(0, typeof value === "undefined" ? this.options.findIndex((item)=>!item.disabled) || 0 : this.options.findIndex((item)=>item.value === value) || 0);
    }
    getPageOffset(index) {
        if (index === 0) {
            return 0;
        }
        const height = this.getListHeight();
        return Math.floor(index / height) * height;
    }
    getOptionByValue(value) {
        return this.options.find((option)=>option.value === value);
    }
    read() {
        if (!this.settings.search) {
            this.tty.cursorHide();
        }
        return super.read();
    }
    async handleEvent(event) {
        switch(true){
            case this.isKey(this.settings.keys, "previous", event):
                this.selectPrevious();
                break;
            case this.isKey(this.settings.keys, "next", event):
                this.selectNext();
                break;
            case this.isKey(this.settings.keys, "nextPage", event):
                this.selectNextPage();
                break;
            case this.isKey(this.settings.keys, "previousPage", event):
                this.selectPreviousPage();
                break;
            default:
                await super.handleEvent(event);
        }
    }
    moveCursorLeft() {
        if (this.settings.search) {
            super.moveCursorLeft();
        }
    }
    moveCursorRight() {
        if (this.settings.search) {
            super.moveCursorRight();
        }
    }
    deleteChar() {
        if (this.settings.search) {
            super.deleteChar();
        }
    }
    deleteCharRight() {
        if (this.settings.search) {
            super.deleteCharRight();
            this.match();
        }
    }
    addChar(__char) {
        if (this.settings.search) {
            super.addChar(__char);
            this.match();
        }
    }
    selectPrevious() {
        if (this.options.length < 2) {
            return;
        }
        if (this.listIndex > 0) {
            this.listIndex--;
            if (this.listIndex < this.listOffset) {
                this.listOffset--;
            }
            if (this.options[this.listIndex].disabled) {
                this.selectPrevious();
            }
        } else {
            this.listIndex = this.options.length - 1;
            this.listOffset = this.options.length - this.getListHeight();
            if (this.options[this.listIndex].disabled) {
                this.selectPrevious();
            }
        }
    }
    selectNext() {
        if (this.options.length < 2) {
            return;
        }
        if (this.listIndex < this.options.length - 1) {
            this.listIndex++;
            if (this.listIndex >= this.listOffset + this.getListHeight()) {
                this.listOffset++;
            }
            if (this.options[this.listIndex].disabled) {
                this.selectNext();
            }
        } else {
            this.listIndex = this.listOffset = 0;
            if (this.options[this.listIndex].disabled) {
                this.selectNext();
            }
        }
    }
    selectPreviousPage() {
        if (this.options?.length) {
            const height = this.getListHeight();
            if (this.listOffset >= height) {
                this.listIndex -= height;
                this.listOffset -= height;
            } else if (this.listOffset > 0) {
                this.listIndex -= this.listOffset;
                this.listOffset = 0;
            }
        }
    }
    selectNextPage() {
        if (this.options?.length) {
            const height = this.getListHeight();
            if (this.listOffset + height + height < this.options.length) {
                this.listIndex += height;
                this.listOffset += height;
            } else if (this.listOffset + height < this.options.length) {
                const offset = this.options.length - height;
                this.listIndex += offset - this.listOffset;
                this.listOffset = offset;
            }
        }
    }
}
class Checkbox extends GenericList {
    static inject(value) {
        GenericPrompt.inject(value);
    }
    static prompt(options) {
        return new this({
            pointer: brightBlue(Figures.POINTER_SMALL),
            prefix: yellow("? "),
            indent: " ",
            listPointer: brightBlue(Figures.POINTER),
            maxRows: 10,
            searchLabel: brightBlue(Figures.SEARCH),
            minOptions: 0,
            maxOptions: Infinity,
            check: green(Figures.TICK),
            uncheck: red(Figures.CROSS),
            ...options,
            keys: {
                check: [
                    "space"
                ],
                ...options.keys ?? {}
            },
            options: Checkbox.mapOptions(options)
        }).prompt();
    }
    static separator(label) {
        return {
            ...super.separator(label),
            icon: false
        };
    }
    static mapOptions(options) {
        return options.options.map((item)=>typeof item === "string" ? {
                value: item
            } : item).map((item)=>({
                ...this.mapOption(item),
                checked: typeof item.checked === "undefined" && options.default && options.default.indexOf(item.value) !== -1 ? true : !!item.checked,
                icon: typeof item.icon === "undefined" ? true : item.icon
            }));
    }
    getListItem(item, isSelected) {
        let line = this.settings.indent;
        line += isSelected ? this.settings.listPointer + " " : "  ";
        if (item.icon) {
            let check = item.checked ? this.settings.check + " " : this.settings.uncheck + " ";
            if (item.disabled) {
                check = dim(check);
            }
            line += check;
        } else {
            line += "  ";
        }
        line += `${isSelected && !item.disabled ? this.highlight(item.name, (val)=>val) : this.highlight(item.name)}`;
        return line;
    }
    getValue() {
        return this.settings.options.filter((item)=>item.checked).map((item)=>item.value);
    }
    async handleEvent(event) {
        switch(true){
            case this.isKey(this.settings.keys, "check", event):
                this.checkValue();
                break;
            default:
                await super.handleEvent(event);
        }
    }
    checkValue() {
        const item = this.options[this.listIndex];
        if (item.disabled) {
            this.setErrorMessage("This option is disabled and cannot be changed.");
        } else {
            item.checked = !item.checked;
        }
    }
    validate(value) {
        const isValidValue = Array.isArray(value) && value.every((val)=>typeof val === "string" && val.length > 0 && this.settings.options.findIndex((option)=>option.value === val) !== -1);
        if (!isValidValue) {
            return false;
        }
        if (value.length < this.settings.minOptions) {
            return `The minimum number of options is ${this.settings.minOptions} but got ${value.length}.`;
        }
        if (value.length > this.settings.maxOptions) {
            return `The maximum number of options is ${this.settings.maxOptions} but got ${value.length}.`;
        }
        return true;
    }
    transform(value) {
        return value.map((val)=>val.trim());
    }
    format(value) {
        return value.map((val)=>this.getOptionByValue(val)?.name ?? val).join(", ");
    }
}
const sep3 = Deno.build.os === "windows" ? "\\" : "/";
class GenericSuggestions extends GenericInput {
    suggestionsIndex = -1;
    suggestionsOffset = 0;
    suggestions = [];
    #hasReadPermissions;
    constructor(settings){
        super({
            ...settings,
            keys: {
                complete: [
                    "tab"
                ],
                next: [
                    "up"
                ],
                previous: [
                    "down"
                ],
                nextPage: [
                    "pageup"
                ],
                previousPage: [
                    "pagedown"
                ],
                ...settings.keys ?? {}
            }
        });
    }
    get localStorage() {
        if (this.settings.id && "localStorage" in window) {
            try {
                return window.localStorage;
            } catch (_) {}
        }
        return null;
    }
    loadSuggestions() {
        if (this.settings.id) {
            const json = this.localStorage?.getItem(this.settings.id);
            const suggestions = json ? JSON.parse(json) : [];
            if (!Array.isArray(suggestions)) {
                return [];
            }
            return suggestions;
        }
        return [];
    }
    saveSuggestions(...suggestions) {
        if (this.settings.id) {
            this.localStorage?.setItem(this.settings.id, JSON.stringify([
                ...suggestions,
                ...this.loadSuggestions()
            ].filter(uniqueSuggestions)));
        }
    }
    async render() {
        if (this.settings.files && this.#hasReadPermissions === undefined) {
            const status = await Deno.permissions.request({
                name: "read"
            });
            this.#hasReadPermissions = status.state === "granted";
        }
        await this.match();
        return super.render();
    }
    async match() {
        this.suggestions = await this.getSuggestions();
        this.suggestionsIndex = Math.max(this.getCurrentInputValue().trim().length === 0 ? -1 : 0, Math.min(this.suggestions.length - 1, this.suggestionsIndex));
        this.suggestionsOffset = Math.max(0, Math.min(this.suggestions.length - this.getListHeight(), this.suggestionsOffset));
    }
    input() {
        return super.input() + dim(this.getSuggestion());
    }
    getSuggestion() {
        return this.suggestions[this.suggestionsIndex]?.toString().substr(this.getCurrentInputValue().length) ?? "";
    }
    async getUserSuggestions(input) {
        return typeof this.settings.suggestions === "function" ? await this.settings.suggestions(input) : this.settings.suggestions ?? [];
    }
    #isFileModeEnabled() {
        return !!this.settings.files && this.#hasReadPermissions === true;
    }
    async getFileSuggestions(input) {
        if (!this.#isFileModeEnabled()) {
            return [];
        }
        const path = await Deno.stat(input).then((file)=>file.isDirectory ? input : dirname2(input)).catch(()=>dirname2(input));
        return await listDir(path, this.settings.files);
    }
    async getSuggestions() {
        const input = this.getCurrentInputValue();
        const suggestions = [
            ...this.loadSuggestions(),
            ...await this.getUserSuggestions(input),
            ...await this.getFileSuggestions(input)
        ].filter(uniqueSuggestions);
        if (!input.length) {
            return suggestions;
        }
        return suggestions.filter((value)=>stripColor(value.toString()).toLowerCase().startsWith(input.toLowerCase())).sort((a, b)=>distance((a || a).toString(), input) - distance((b || b).toString(), input));
    }
    body() {
        return this.getList() + this.getInfo();
    }
    getInfo() {
        if (!this.settings.info) {
            return "";
        }
        const selected = this.suggestionsIndex + 1;
        const matched = this.suggestions.length;
        const actions = [];
        if (this.suggestions.length) {
            if (this.settings.list) {
                actions.push([
                    "Next",
                    getFiguresByKeys(this.settings.keys?.next ?? [])
                ], [
                    "Previous",
                    getFiguresByKeys(this.settings.keys?.previous ?? [])
                ], [
                    "Next Page",
                    getFiguresByKeys(this.settings.keys?.nextPage ?? [])
                ], [
                    "Previous Page",
                    getFiguresByKeys(this.settings.keys?.previousPage ?? [])
                ]);
            } else {
                actions.push([
                    "Next",
                    getFiguresByKeys(this.settings.keys?.next ?? [])
                ], [
                    "Previous",
                    getFiguresByKeys(this.settings.keys?.previous ?? [])
                ]);
            }
            actions.push([
                "Complete",
                getFiguresByKeys(this.settings.keys?.complete ?? [])
            ]);
        }
        actions.push([
            "Submit",
            getFiguresByKeys(this.settings.keys?.submit ?? [])
        ]);
        let info = this.settings.indent;
        if (this.suggestions.length) {
            info += brightBlue(Figures.INFO) + bold(` ${selected}/${matched} `);
        }
        info += actions.map((cur)=>`${cur[0]}: ${bold(cur[1].join(" "))}`).join(", ");
        return info;
    }
    getList() {
        if (!this.suggestions.length || !this.settings.list) {
            return "";
        }
        const list = [];
        const height = this.getListHeight();
        for(let i = this.suggestionsOffset; i < this.suggestionsOffset + height; i++){
            list.push(this.getListItem(this.suggestions[i], this.suggestionsIndex === i));
        }
        if (list.length && this.settings.info) {
            list.push("");
        }
        return list.join("\n");
    }
    getListItem(value, isSelected) {
        let line = this.settings.indent ?? "";
        line += isSelected ? `${this.settings.listPointer} ` : "  ";
        if (isSelected) {
            line += underline(this.highlight(value));
        } else {
            line += this.highlight(value);
        }
        return line;
    }
    getListHeight(suggestions = this.suggestions) {
        return Math.min(suggestions.length, this.settings.maxRows || suggestions.length);
    }
    async handleEvent(event) {
        switch(true){
            case this.isKey(this.settings.keys, "next", event):
                if (this.settings.list) {
                    this.selectPreviousSuggestion();
                } else {
                    this.selectNextSuggestion();
                }
                break;
            case this.isKey(this.settings.keys, "previous", event):
                if (this.settings.list) {
                    this.selectNextSuggestion();
                } else {
                    this.selectPreviousSuggestion();
                }
                break;
            case this.isKey(this.settings.keys, "nextPage", event):
                if (this.settings.list) {
                    this.selectPreviousSuggestionsPage();
                } else {
                    this.selectNextSuggestionsPage();
                }
                break;
            case this.isKey(this.settings.keys, "previousPage", event):
                if (this.settings.list) {
                    this.selectNextSuggestionsPage();
                } else {
                    this.selectPreviousSuggestionsPage();
                }
                break;
            case this.isKey(this.settings.keys, "complete", event):
                await this.#completeValue();
                break;
            case this.isKey(this.settings.keys, "moveCursorRight", event):
                if (this.inputIndex < this.inputValue.length) {
                    this.moveCursorRight();
                } else {
                    await this.#completeValue();
                }
                break;
            default:
                await super.handleEvent(event);
        }
    }
    deleteCharRight() {
        if (this.inputIndex < this.inputValue.length) {
            super.deleteCharRight();
            if (!this.getCurrentInputValue().length) {
                this.suggestionsIndex = -1;
                this.suggestionsOffset = 0;
            }
        }
    }
    async #completeValue() {
        this.inputValue = await this.complete();
        this.inputIndex = this.inputValue.length;
        this.suggestionsIndex = 0;
        this.suggestionsOffset = 0;
    }
    async complete() {
        let input = this.getCurrentInputValue();
        const suggestion = this.suggestions[this.suggestionsIndex]?.toString();
        if (this.settings.complete) {
            input = await this.settings.complete(input, suggestion);
        } else if (this.#isFileModeEnabled() && input.at(-1) !== sep3 && await isDirectory(input) && (this.getCurrentInputValue().at(-1) !== "." || this.getCurrentInputValue().endsWith(".."))) {
            input += sep3;
        } else if (suggestion) {
            input = suggestion;
        }
        return this.#isFileModeEnabled() ? normalize3(input) : input;
    }
    selectPreviousSuggestion() {
        if (this.suggestions.length) {
            if (this.suggestionsIndex > -1) {
                this.suggestionsIndex--;
                if (this.suggestionsIndex < this.suggestionsOffset) {
                    this.suggestionsOffset--;
                }
            }
        }
    }
    selectNextSuggestion() {
        if (this.suggestions.length) {
            if (this.suggestionsIndex < this.suggestions.length - 1) {
                this.suggestionsIndex++;
                if (this.suggestionsIndex >= this.suggestionsOffset + this.getListHeight()) {
                    this.suggestionsOffset++;
                }
            }
        }
    }
    selectPreviousSuggestionsPage() {
        if (this.suggestions.length) {
            const height = this.getListHeight();
            if (this.suggestionsOffset >= height) {
                this.suggestionsIndex -= height;
                this.suggestionsOffset -= height;
            } else if (this.suggestionsOffset > 0) {
                this.suggestionsIndex -= this.suggestionsOffset;
                this.suggestionsOffset = 0;
            }
        }
    }
    selectNextSuggestionsPage() {
        if (this.suggestions.length) {
            const height = this.getListHeight();
            if (this.suggestionsOffset + height + height < this.suggestions.length) {
                this.suggestionsIndex += height;
                this.suggestionsOffset += height;
            } else if (this.suggestionsOffset + height < this.suggestions.length) {
                const offset = this.suggestions.length - height;
                this.suggestionsIndex += offset - this.suggestionsOffset;
                this.suggestionsOffset = offset;
            }
        }
    }
}
function uniqueSuggestions(value, index, self1) {
    return typeof value !== "undefined" && value !== "" && self1.indexOf(value) === index;
}
function isDirectory(path) {
    return Deno.stat(path).then((file)=>file.isDirectory).catch(()=>false);
}
async function listDir(path, mode) {
    const fileNames = [];
    for await (const file of Deno.readDir(path || ".")){
        if (mode === true && (file.name.startsWith(".") || file.name.endsWith("~"))) {
            continue;
        }
        const filePath = join3(path, file.name);
        if (mode instanceof RegExp && !mode.test(filePath)) {
            continue;
        }
        fileNames.push(filePath);
    }
    return fileNames.sort(function(a, b) {
        return a.toLowerCase().localeCompare(b.toLowerCase());
    });
}
class Input extends GenericSuggestions {
    static prompt(options) {
        if (typeof options === "string") {
            options = {
                message: options
            };
        }
        return new this({
            pointer: brightBlue(Figures.POINTER_SMALL),
            prefix: yellow("? "),
            indent: " ",
            listPointer: brightBlue(Figures.POINTER),
            maxRows: 8,
            minLength: 0,
            maxLength: Infinity,
            ...options
        }).prompt();
    }
    static inject(value) {
        GenericPrompt.inject(value);
    }
    success(value) {
        this.saveSuggestions(value);
        return super.success(value);
    }
    getValue() {
        return this.settings.files ? normalize3(this.inputValue) : this.inputValue;
    }
    validate(value) {
        if (typeof value !== "string") {
            return false;
        }
        if (value.length < this.settings.minLength) {
            return `Value must be longer than ${this.settings.minLength} but has a length of ${value.length}.`;
        }
        if (value.length > this.settings.maxLength) {
            return `Value can't be longer than ${this.settings.maxLength} but has a length of ${value.length}.`;
        }
        return true;
    }
    transform(value) {
        return value.trim();
    }
    format(value) {
        return value;
    }
}
class Select extends GenericList {
    listIndex = this.getListIndex(this.settings.default);
    static inject(value) {
        GenericPrompt.inject(value);
    }
    static prompt(options) {
        return new this({
            pointer: brightBlue(Figures.POINTER_SMALL),
            prefix: yellow("? "),
            indent: " ",
            listPointer: brightBlue(Figures.POINTER),
            maxRows: 10,
            searchLabel: brightBlue(Figures.SEARCH),
            ...options,
            options: Select.mapOptions(options)
        }).prompt();
    }
    static mapOptions(options) {
        return options.options.map((item)=>typeof item === "string" ? {
                value: item
            } : item).map((item)=>this.mapOption(item));
    }
    input() {
        return underline(brightBlue(this.inputValue));
    }
    getListItem(item, isSelected) {
        let line = this.settings.indent;
        line += isSelected ? `${this.settings.listPointer} ` : "  ";
        line += `${isSelected && !item.disabled ? this.highlight(item.name, (val)=>val) : this.highlight(item.name)}`;
        return line;
    }
    getValue() {
        return this.options[this.listIndex]?.value ?? this.settings.default;
    }
    validate(value) {
        return typeof value === "string" && value.length > 0 && this.options.findIndex((option)=>option.value === value) !== -1;
    }
    transform(value) {
        return value.trim();
    }
    format(value) {
        return this.getOptionByValue(value)?.name ?? value;
    }
}
class Toggle extends GenericPrompt {
    status = typeof this.settings.default !== "undefined" ? this.format(this.settings.default) : "";
    static prompt(options) {
        if (typeof options === "string") {
            options = {
                message: options
            };
        }
        return new this({
            pointer: brightBlue(Figures.POINTER_SMALL),
            prefix: yellow("? "),
            indent: " ",
            active: "Yes",
            inactive: "No",
            ...options,
            keys: {
                active: [
                    "right",
                    "y",
                    "j",
                    "s",
                    "o"
                ],
                inactive: [
                    "left",
                    "n"
                ],
                ...options.keys ?? {}
            }
        }).prompt();
    }
    message() {
        let message = super.message() + " " + this.settings.pointer + " ";
        if (this.status === this.settings.active) {
            message += dim(this.settings.inactive + " / ") + underline(this.settings.active);
        } else if (this.status === this.settings.inactive) {
            message += underline(this.settings.inactive) + dim(" / " + this.settings.active);
        } else {
            message += dim(this.settings.inactive + " / " + this.settings.active);
        }
        return message;
    }
    read() {
        this.tty.cursorHide();
        return super.read();
    }
    async handleEvent(event) {
        switch(true){
            case event.sequence === this.settings.inactive[0].toLowerCase():
            case this.isKey(this.settings.keys, "inactive", event):
                this.selectInactive();
                break;
            case event.sequence === this.settings.active[0].toLowerCase():
            case this.isKey(this.settings.keys, "active", event):
                this.selectActive();
                break;
            default:
                await super.handleEvent(event);
        }
    }
    selectActive() {
        this.status = this.settings.active;
    }
    selectInactive() {
        this.status = this.settings.inactive;
    }
    validate(value) {
        return [
            this.settings.active,
            this.settings.inactive
        ].indexOf(value) !== -1;
    }
    transform(value) {
        switch(value){
            case this.settings.active:
                return true;
            case this.settings.inactive:
                return false;
        }
    }
    format(value) {
        return value ? this.settings.active : this.settings.inactive;
    }
    getValue() {
        return this.status;
    }
}
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
const sep4 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join4(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator1);
}
function basename3(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment(path, isPathSeparator1, start);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator1);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse5(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod4 = {
    sep: sep4,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join4,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse5,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep5 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator1(path.charCodeAt(path.length - 1));
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && isPosixPathSeparator1(path.charCodeAt(0));
}
function join5(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator1(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator1(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator1(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator1(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator1(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator1(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator1(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator1(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator1(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator1);
}
function basename4(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment(path, isPosixPathSeparator1);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator1);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse6(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator1);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod5 = {
    sep: sep5,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join5,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse6,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path2 = isWindows1 ? mod4 : mod5;
const { join: join6 , normalize: normalize6  } = path2;
const path3 = isWindows1 ? mod4 : mod5;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join7 , normalize: normalize7 , parse: parse7 , relative: relative5 , resolve: resolve5 , sep: sep6 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5  } = path3;
factory1();
function factory1() {
    let result = [];
    let stack = [];
    const ansi = function(...args) {
        if (this) {
            if (args.length) {
                update(args);
                return this;
            }
            return this.toString();
        }
        return factory1();
    };
    ansi.text = function(text) {
        stack.push([
            text,
            []
        ]);
        return this;
    };
    ansi.toString = function() {
        update();
        const str = result.join("");
        result = [];
        return str;
    };
    ansi.toBuffer = function() {
        return new TextEncoder().encode(this.toString());
    };
    const methodList = Object.entries(mod1);
    for (const [name, method] of methodList){
        Object.defineProperty(ansi, name, {
            get () {
                stack.push([
                    method,
                    []
                ]);
                return this;
            }
        });
    }
    return ansi;
    function update(args) {
        if (!stack.length) {
            return;
        }
        if (args) {
            stack[stack.length - 1][1] = args;
        }
        result.push(...stack.map(([prop, args])=>typeof prop === "string" ? prop : prop.call(ansi, ...args)));
        stack = [];
    }
}
const proto = Object.create(null);
const methodNames = Object.keys(mod);
for (const name of methodNames){
    if (name === "setColorEnabled" || name === "getColorEnabled") {
        continue;
    }
    Object.defineProperty(proto, name, {
        get () {
            return factory2([
                ...this._stack,
                name
            ]);
        }
    });
}
const colors = factory2();
function factory2(stack = []) {
    const colors = function(str, ...args) {
        if (str) {
            const lastIndex = stack.length - 1;
            return stack.reduce((str, name, index)=>index === lastIndex ? mod[name](str, ...args) : mod[name](str), str);
        }
        const tmp = stack.slice();
        stack = [];
        return factory2(tmp);
    };
    Object.setPrototypeOf(colors, proto);
    colors._stack = stack;
    return colors;
}
async function isDirEmpty(outputDir) {
    const contents = Deno.readDir(outputDir);
    for await (const _ of contents){
        return false;
    }
    return true;
}
function getFileInfoType(fileInfo) {
    return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : undefined;
}
async function ensureDir(dir) {
    try {
        const fileInfo = await Deno.lstat(dir);
        if (!fileInfo.isDirectory) {
            throw new Error(`Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`);
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
            await Deno.mkdir(dir, {
                recursive: true
            });
            return;
        }
        throw err;
    }
}
const error = colors.bold.red;
const progress = colors.bold.yellow;
const success = colors.bold.green;
const KOTLIN_ADVANCED_OPTION = "Kotlin Programming Language";
const DATAGEN_ADVANCED_OPTION = "Data Generation";
const SPLIT_ADVANCED_OPTION = "Split client and common sources";
const ADVANCED_OPTIONS = new Map([
    [
        "kotlin",
        KOTLIN_ADVANCED_OPTION
    ],
    [
        "datagen",
        DATAGEN_ADVANCED_OPTION
    ],
    [
        "splitSources",
        SPLIT_ADVANCED_OPTION
    ]
]);
const optionArg = {
    conflicts: [
        "defaultOptions"
    ],
    hidden: true
};
function initCommand() {
    return new Command().name("init").description("Generate a new fabric project").option("-y, --defaultOptions", "Generate a mod with default options").option("-n, --name <name:string>", "The name of the mod", optionArg).option("-m, --modid <modid:string>", "The modid of the mod", optionArg).option("-p, --packageName <packageName:string>", "The package name of the mod", optionArg).option("-v, --version <version:string>", "The minecraft version", optionArg).option("-o, --option [advancedOption:string]", "Specify an advanced option, one of" + Object.keys(ADVANCED_OPTIONS).join(","), {
        ...optionArg,
        collect: true
    }).arguments("[dir:file]").action(async (options, dir)=>{
        await generate(options, dir);
    });
}
async function generate(cli, outputDirName) {
    const outputDir = await getAndPrepareOutputDir(outputDirName);
    const isTargetEmpty = await isDirEmpty(outputDir);
    if (!isTargetEmpty) {
        fatalError("The target directory must be empty");
    }
    const config = await (cli.defaultOptions ? defaultOptions(basename5(outputDir)) : promptUser(basename5(outputDir), cli));
    const options = {
        config,
        writer: {
            write: async (contentPath, content, options)=>{
                await writeFile(outputDir, contentPath, content, options);
            }
        }
    };
    console.log(progress("Generating mod template..."));
    await generateTemplate(options);
    console.log(success("Done!"));
}
async function getAndPrepareOutputDir(outputDirName) {
    if (outputDirName == undefined) {
        await requestPermissions(".");
        return resolve5(Deno.cwd());
    }
    await requestPermissions(outputDirName);
    const outputDir = resolve5(outputDirName);
    await ensureDir(outputDir);
    return outputDir;
}
async function promptUser(startingName, cli) {
    const minecraftVersionsPromise = getTemplateGameVersions();
    validateCliOptions(cli);
    const modName = cli.name ?? await Input.prompt({
        message: "Choose a name",
        default: startingName,
        minLength: 2
    });
    const modId = cli.modid ?? await Input.prompt({
        message: "Choose a unique modid",
        default: nameToModId(modName),
        minLength: 2,
        maxLength: 64,
        validate: (value)=>{
            const errors = computeCustomModIdErrors(value);
            if (errors == undefined) {
                return true;
            }
            return errors.join(", ");
        }
    });
    const packageName = cli.packageName ?? await Input.prompt({
        message: "Choose a package name",
        default: formatPackageName(modId),
        transform: (value)=>{
            return formatPackageName(value);
        },
        validate: (value)=>{
            const errors = computePackageNameErrors(value);
            if (errors.length == 0) {
                return true;
            }
            return errors.join(", ");
        }
    });
    const minecraftVersions = await minecraftVersionsPromise;
    let minecraftVersion;
    if (cli.version != undefined) {
        minecraftVersion = cli.version;
        if (!minecraftVersions.map((v)=>v.version).includes(minecraftVersion)) {
            fatalError(`The minecraft version ${minecraftVersion} does not exist.`);
        }
    } else {
        minecraftVersion = await Select.prompt({
            message: "Select the minecraft version",
            options: minecraftVersions.map((v)=>v.version)
        });
    }
    const cliOptions = cli.option?.map((o)=>{
        if (o === true) {
            fatalError("Advanced options must be specified with a value");
            return "unreachable";
        }
        const option = o;
        if (!ADVANCED_OPTIONS.has(option)) {
            fatalError(`Unknown option ${o} must be one of: ${Array.from(ADVANCED_OPTIONS.keys()).join(", ")}`);
        }
        return ADVANCED_OPTIONS.get(option);
    });
    const advancedOptions = cliOptions ?? await Checkbox.prompt({
        message: "Advanced options",
        options: getAdancedOptions(minecraftVersion)
    });
    return {
        modid: modId,
        minecraftVersion: minecraftVersion,
        projectName: modName,
        packageName: packageName,
        useKotlin: advancedOptions.includes(KOTLIN_ADVANCED_OPTION),
        dataGeneration: advancedOptions.includes(DATAGEN_ADVANCED_OPTION),
        splitSources: advancedOptions.includes(SPLIT_ADVANCED_OPTION)
    };
}
function validateCliOptions(cli) {
    if (cli.modid != undefined) {
        const errors = computeCustomModIdErrors(cli.modid);
        if (errors != undefined) {
            fatalError(errors.join(", "));
        }
    }
    if (cli.packageName != undefined) {
        const errors = computePackageNameErrors(cli.packageName);
        if (errors.length > 0) {
            fatalError(errors.join(", "));
        }
    }
}
async function defaultOptions(startingName) {
    const minecraftVersions = await getTemplateGameVersions();
    const minecraftVersion = minecraftVersions[0].version;
    return {
        modid: nameToModId(startingName),
        minecraftVersion: minecraftVersion,
        projectName: startingName,
        packageName: formatPackageName(nameToModId(startingName)),
        useKotlin: false,
        dataGeneration: false,
        splitSources: minecraftSupportsSplitSources(minecraftVersion)
    };
}
function getAdancedOptions(minecraftVersion) {
    const options = [
        {
            value: KOTLIN_ADVANCED_OPTION
        }
    ];
    if (minecraftSupportsDataGen(minecraftVersion)) {
        options.push({
            value: DATAGEN_ADVANCED_OPTION
        });
    }
    if (minecraftSupportsSplitSources(minecraftVersion)) {
        options.push({
            value: SPLIT_ADVANCED_OPTION,
            checked: true
        });
    }
    return options;
}
async function writeFile(outputPath, filePath, content, options) {
    const output = join7(outputPath, filePath);
    await tryMkdirs(dirname5(output));
    const writeOptions = {
        mode: options?.executable ? 0o744 : undefined
    };
    if (content instanceof ArrayBuffer) {
        const data = new Uint8Array(content);
        await Deno.writeFile(output, data, writeOptions);
    } else {
        await Deno.writeTextFile(output, content, writeOptions);
    }
}
async function tryMkdirs(path) {
    try {
        await Deno.mkdir(path, {
            recursive: true
        });
    } catch (error) {
        if (!(error instanceof Deno.errors.AlreadyExists)) {
            throw error;
        }
    }
}
async function requestPermissions(outputDir) {
    const permissions = [
        {
            name: "read",
            path: Deno.cwd()
        },
        {
            name: "read",
            path: outputDir
        },
        {
            name: "write",
            path: outputDir
        },
        {
            name: "net",
            host: "meta.fabricmc.net"
        },
        {
            name: "net",
            host: "maven.fabricmc.net"
        }
    ];
    for (const permission of permissions){
        const status = await Deno.permissions.request(permission);
        if (status.state != "granted") {
            fatalError("Permission not granted");
        }
    }
}
function fatalError(message) {
    console.error(error(message));
    Deno.exit(1);
}
const UPGRADE_URL = "https://fabricmc.net/cli";
const COMMAND_NAME = "fabric";
function upgradeCommand() {
    const command = new UpgradeCommand({
        provider: new UpdateProvider()
    }).description("Upgrade Fabric CLI tools executable to latest version");
    command.removeOption("--version");
    command.removeOption("--force");
    command.removeOption("--list-versions");
    return command;
}
class UpdateProvider extends Provider {
    name = COMMAND_NAME;
    async upgrade({}) {
        const args = [
            "install",
            "--force",
            "--reload",
            "--quiet",
            "-A",
            "--name",
            COMMAND_NAME,
            UPGRADE_URL
        ];
        const command = new Deno.Command(Deno.execPath(), {
            args
        });
        const { success , stderr  } = await command.output();
        if (!success) {
            await Deno.stderr.write(stderr);
            throw new Error(`Failed to upgrade ${COMMAND_NAME}!`);
        }
        console.info(`Successfully upgraded!`);
    }
    getVersions(_) {
        return Promise.resolve({
            latest: "latest",
            versions: [
                "latest"
            ]
        });
    }
    getRepositoryUrl(_) {
        throw new Error("Method not implemented.");
    }
    getRegistryUrl(_, __) {
        throw new Error("Method not implemented.");
    }
    isOutdated(_, __, ___) {
        return Promise.resolve(true);
    }
}
const importMeta = {
    url: "file:///home/runner/work/fabricmc.net/fabricmc.net/cli/main.ts",
    main: import.meta.main
};
setXmlVersionParser((xml)=>{
    const document = parse(xml);
    return document.metadata.versioning.versions.version;
});
if (importMeta.main) {
    const cmd = new Command().name("Fabric CLI tools").version("2023-12-15 16:19:55").description("A set of command line tools to aid Fabric mod development").action(()=>{
        cmd.showHelp();
        Deno.exit(0);
    }).command("init", initCommand()).command("upgrade", upgradeCommand()).command("completions", new CompletionsCommand());
    await cmd.parse();
}
